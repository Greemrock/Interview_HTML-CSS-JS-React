<details>
  <summary>Что такое семантическая вёрстка и зачем она нужна?</summary>
  <br>
  <ul>
    <li>Чтобы сделать сайт доступным. Зрячие пользователи могут без проблем с первого взгляда понять, где какая часть
      страницы находится — где заголовок, списки или изображения. Для незрячих или плохо видящих основной инструмент для
      просмотра сайтов не браузер, который отрисовывает страницу, а скринридер, который читает текст со страницы вслух.
    </li>
    <li>Чтобы сайт был выше в поисковиках. Наличие семантической разметки страниц помогает поисковым ботам лучше
      понимать, что находится на странице, и в зависимости от этого ранжировать сайты в поисковой выдаче.</li>
    <li>Tags: article, section, aside, nav, header, main, footer, h1-h6, ul...</li>
</details>

<details>
  <summary>Что такое DNS(Domain Name System)?</summary>
  <br>
  <p>Это глобальное распределенное хранилище ключей и значений. Сервера по всему миру могут предоставить вам значение по
    ключу, а если им неизвестен ключ, то они попросят помощи у другого сервера.</p>
  <p>Вы или ваш браузер запрашивает значение для ключа www.example.com, и получает в ответ 1.2.3.4.</p>
  <p><i>Источник: <a href='https://habr.com/ru/post/303446/'>habr.com</a></i></p>
</details>

<details>
  <summary>Как работают браузеры(HTTP)?</summary>
  <br>
  <div>
    <span>Работа браузера в основном состоит из:
      <ul>
        <li>Разрешение DNS</li>
        <li>HTTP-обмен</li>
        <li>Рендеринг</li>
        <li>Сброс и повтор</li>
      </ul>
  </div>
  <h4>Разрешение DNS</h4>
  <p>Этот процесс помогает браузеру узнать, к какому серверу он должен подключиться, когда пользователь вводит URL.
    Браузер связывается с DNS-сервером и обнаруживает, что google.com соответствует набору цифр 216.58.207.110 —
    IP-адресу, к которому может подключиться браузер.
  <p>
  <h4>HTTP-обмен</h4>
  <p>Как только браузер определит, какой сервер будет обслуживать наш запрос, он установит с ним TCP-соединение и начнет
    HTTP-обмен.
  <p>
  <p>HTTP — это просто название самого популярного протокола для общения в сети, и браузеры в основном выбирают HTTP при
    общении с серверами. HTTP-обмен подразумевает, что клиент (наш браузер) отправляет запрос, а сервер присылает ответ.
  <p>
  <h4>Рендеринг</h4>
  <p>В теле ответа сервер включает представление запрашиваемого документа в соответствии с заголовком Content-Type. В
    нашем случае тип содержимого был установлен на text/html, поэтому мы ожидаем HTML-разметку в ответе — и именно ее мы
    и находим в теле документа.
  <p>
  <p>Это как раз тот момент, где браузер действительно проявляет свои способности. Он считывает и анализирует HTML-код,
    загружает дополнительные ресурсы, включенные в разметку (например, там могут быть указаны для подгрузки
    JavaScript-файлы или CSS-документы) и представляет их пользователю как можно скорее.</p>
  <p><i>Источник: <a href='https://habr.com/ru/company/edison/blog/432870/'>habr.com</a></i></p>
</details>

<details>
  <summary>Разница между LocalStorage, SessionStorage, Cookies</summary>
  <br>
  <span>Local Storage (локальное хранилище)</span>
  <ul>
    <li>Хранит данные бессрочно.</li>
    <li>Очищается только с помощью JavaScript или очистки кэша браузера.</li>
    <li>Хранит данные объёмом до 5 МБ, это самый большой объём из трёх вариантов хранилища.</li>
    <li>Не поддерживается старыми браузерами, например, IE 7 и ниже.</li>
    <li>Работает по правилу ограничения домена (same origin policy). То есть сохранённые данные доступны только для
      одного источника.</li>
  </ul>
  <br>
  <span>Session Storage (сессионное хранилище)</span>
  <ul>
    <li>Хранит данные, пока продолжается текущая сессия. Когда пользователь закрывает браузер, данные становятся
      недоступными.</li>
    <li>Используется контекст браузера верхнего уровня, поэтому каждая вкладка браузера хранит уникальные данные.</li>
    <li>Объём данных больше чем в Cookie.</li>
    <li>Не поддерживается старыми браузерами, например, IE 7 и ниже.</li>
  </ul>
  <br>
  <span>Cookie</span>
  <ul>
    <li>Хранит данные, которые можно передавать на сервер через заголовки.</li>
    <li>Локальное и сессионное хранилище доступны только на клиентской стороне.</li>
    <li>Срок хранения устанавливается при создании cookie.</li>
    <li>Объём данных не превышает 4 Кбайт.</li>
    <li>Cookie могут быть защищёнными, в этом случае их содержимое нельзя получить на стороне клиента. Это важно для
      аутентификации при хранении пользовательских токенов.</li>
  </ul>
  <p><i>Источник: <a
        href='https://ru.hexlet.io/blog/posts/lokalnoe-hranilische-vs-sessionnoe-hranilische-vs-cookie'>hexlet.io</a></i>
  </p>
</details>

<br>
<b>CSS</b>

<details>
  <summary>Что такое селекторы?</summary>
  <br>
  <p>Селектор определяет, к какому элементу применять то или иное CSS-правило.</p>
  <span>Основных видов селекторов всего несколько:</span>
  <ul>
    <li>* – любые элементы.</li>
    <li>div – элементы с таким тегом.</li>
    <li>#id – элемент с данным id.</li>
    <li>.class – элементы с таким классом.</li>
    <li>[name="value"] – селекторы на атрибут</li>
    <li>:visited – «псевдоклассы», остальные разные условия на элемент</li>
  </ul>
  <br>
  <p><i>Источник: <a href='https://learn.javascript.ru/css-selectors'>javascript.ru</a></i></p>
</details>

<details>
  <summary>Что такое спецефичность селекторов?</summary>
  <br>
  <p>Специфичность - это способ, с помощью которого браузеры определяют, какие значения свойств CSS наиболее
    соответствуют элементу и, следовательно, будут применены.</p>
  <span>Спецефичность селекторов:</span>
  <table>
    <tbody>
      <tr>
        <td>Селектор тега:</td>
        <td>1</td>
      </tr>
      <tr>
        <td>Селектор класса:</td>
        <td>10</td>
      </tr>
      <tr>
        <td>Селектор ID:</td>
        <td>100</td>
      </tr>
      <tr>
        <td>Inline-стиль:</td>
        <td>1000</td>
      </tr>
    </tbody>
  </table>
  <p><i>Источник: <a href='https://developer.mozilla.org/ru/docs/Web/CSS/Specificity'>developer.mozilla.org</a></i></p>
</details>

<details>
  <summary>Что такое вложенные селекторы?</summary>
  <br>
  <p>В HTML можно вписать одни теги в другие. В CSS мы можем выбирать те теги, которые вложены в какой-либо тег. Для
    этого используется конструкция вложенных селекторов (A B). Например, мы можем задать стили для всех em, которые
    находятся в тегах div.</p>
  <code>
    #example em {
      color: #cc4d4d;
    }
  </code>
  <p><i>Источник: <a href='https://developer.mozilla.org/ru/docs/Web/CSS/Specificity'>developer.mozilla.org</a></i></p>
</details>

<details>
  <summary>Position</summary>
  <ul>
    <li>
      <span>static</span>
      <p>static ещё называют не позиционированным(отпозиционированы статически, то есть никак).</p>>
    </li>
    <li>
      <span>relative</span>
      <p>Относительное позиционирование сдвигает элемент относительно его обычного положения.</p>>
    </li>
    <li>
      <span>absolute</span>
      <p>Абсолютное позиционирование делает две вещи: Элемент исчезает с того места, где он должен быть и позиционируется заново и Координаты top/bottom/left/right для нового местоположения отсчитываются от ближайшего позиционированного родителя.</p>>
    </li>
    <li>
      <span>fixed</span>
      <p>Позиционирует объект точно так же, как absolute, но относительно window.</p>>
      <p>Когда страницу прокручивают, фиксированный элемент остаётся на своём месте и не прокручивается вместе со страницей.</p>
    </li>
    <li>
      <span>sticky </span>
      <p>sticky может перемещаться только в пределах контейнера, в котором находится.</p>>
    </li>
  </ul>
</details>

<details>
  <summary>display</summary>
  <ul>
    <li>
      <span>none</span>
      <p>Элемент не показывается, вообще. Как будто его и нет.</p>
    </li>
    <li>
      <span>block</span>
      <p>Блочные элементы располагаются один над другим, вертикально (если нет особых свойств позиционирования, например float).</p>
      <p>Блок стремится расшириться на всю доступную ширину. Можно указать ширину и высоту явно.</p>
    </li>
    <li>
      <span>inline</span>
      <p>Блочные элементы располагаются один над другим, вертикально (если нет особых свойств позиционирования, например float).
      </p>
      <p>Блок стремится расшириться на всю доступную ширину. Можно указать ширину и высоту явно.</p>
    </li>
    <li>
      <span>inline-block</span>
      <p>Это значение – означает элемент, который продолжает находиться в строке (inline), но при этом может иметь важные свойства блока.</p>
    </li>
    <li>
      <span>table-*</span>
      <p>Современные браузеры (IE8+) позволяют описывать таблицу любыми элементами, если поставить им соответствующие значения display.</p>
    </li>
    <li>
      <span>flex</span>
    </li>
    <li>
      <span>grid</span>
    </li>
  </ul>
</details>

<br>
<b>JavaScript</b>

<details>
  <summary>Что такое Hoisting?</summary>
  <br>
  <p>Поднятие или hoisting — это механизм в JavaScript, в котором переменные и объявления функций, передвигаются вверх своей области видимости перед тем, как код будет выполнен.</p>
  <p>JavaScript сначала объявляет, а уже затем инициализирует наши переменные.</p>
  <ul>
    <li>
      <span>var</span>
      <p>Областью видимости переменной, объявленной через var, является её настоящий контекст выполнения.</p>
  <code>

    console.log(hoist); // Вывод: undefined
    var hoist = 'The variable has been hoisted.';
    function hoist() {
      console.log(message);
      message='Hoisting is all the rage!'
    }
    hoist(); // Вывод: undefined
  </code>
    </li>
    <li>
      <span>let</span>
      <p>Переменные объявленные через let заключены в область видимости блока, а не функции.</p>
      <p>Вкратце, это просто говорит о том, что область видимости переменной привязана к блоку, в котором она объявлена, а не к функции в которой она объявлена.</p>
  <code>

    console.log(hoist); // Вывод: ReferenceError: hoist is not defined 
    ...
    let hoist = 'The variable has been hoisted.';
  </code>
    </li>
    <li>
      <span>const</span>
      <p>Const была представлена в es6 для того, чтобы можно было сделать неизменные переменные.</p>
    </li>
    <p>Переменные объявленные с let и const остаются неинициализированными в начале выполнения, в то время как переменные объявленные с var инициализируются со значением undefined.</p>
    <br>
    <b>Поднятие функций</b>
    <span>Объявленные функции</span>
    <p>Такие функции полностью поднимаются вверх кода.</p>
  <code>

    hoisted(); // Вывод: "This function has been hoisted."
    function hoisted() {
      console.log('This function has been hoisted.');
    };
  </code>
        <p>Функциональные выражения, однако, не поднимаются.</p>
  <code>

    expression(); //Вывод: "TypeError: expression is not a function
    var expression = function() {
      console.log('Will this work?');
    };
  </code>
  <p>1. Используя es5 переменную var, попытки использования необъявленных переменных приведут к тому, что переменной будет назначено значение undefined при «поднятии».</p>
  <p>2. Используя переменные es6 let и const, использование переменных приведет к Reference Error, потому что переменная останется неинициализированной при выполнении.</p>
  <p><i>Источник: <a href='https://medium.com/@stasonmars/%D1%80%D0%B0%D0%B7%D0%B1%D0%B8%D1%80%D0%B0%D0%B5%D0%BC%D1%81%D1%8F-%D1%81-%D0%BF%D0%BE%D0%B4%D0%BD%D1%8F%D1%82%D0%B8%D0%B5%D0%BC-hoisting-%D0%B2-javascript-7d2d27bc51f1'>medium.com</a></i></p>
</details>

<details>
  <summary>Что такое замыкание?</summary>
  <br>
  <p>Замыкание это функция у которой есть доступ к своей внешней функции по области видимости, даже после того, как внешняя функция прекратилась. Это говорит о том, что замыкание может запоминать и получать доступ к переменным, и аргументам своей внешней функции, даже после того, как та прекратит выполнение.</p>
  <code>

    function getCounter() {
      let counter = 0;
      return function() {
        return counter++;
      }
    }
    let count = getCounter();
    console.log(count());  // 0
    console.log(count());  // 1
    console.log(count());  // 2

  </code>
  <p>Мы храним анонимную внутреннюю функцию, возвращенную функцией getCounter в переменной count. Так как функция сount теперь замыкание, она может получать доступ к переменной counter в функции getCounter, даже после того, как та завершится.</p>
  <p>Но обратите внимание, что значение counter не сбрасывается до 0 при каждом вызове count, как вроде бы она должна делать.
  </p>
  <p>Так происходит, потому что при каждом вызове count(), создаётся новая область видимости, но есть только одна область видимости, созданная для getCounter, так как переменная counter объявлена в области видимости getCounter(), она увеличится при каждом вызове функции count, вместо того, чтобы сброситься до 0.</p>
  <p><i>Источник: <a href='https://medium.com/@stasonmars/%D0%BF%D0%BE%D0%BD%D0%B8%D0%BC%D0%B0%D0%B5%D0%BC-%D0%B7%D0%B0%D0%BC%D1%8B%D0%BA%D0%B0%D0%BD%D0%B8%D1%8F-%D0%B2-javascript-%D1%80%D0%B0%D0%B7-%D0%B8-%D0%BD%D0%B0%D0%B2%D1%81%D0%B5%D0%B3%D0%B4%D0%B0-c211805b6898'>medium.com</a></i></p>
</details>

<details>
  <summary>Что такое контекст выполнения?</summary>
  <br>
  <p>Это абстрактная среда, в которой JavaScript код оценивается и выполняется. Когда выполняется “глобальный” код, он выполняется внутри глобального контекста выполнения, а код функции выполняется внутри контекста выполнения функции.</p>
  <img src="https://miro.medium.com/max/875/1*huMb5-_MmM8zkFVnchsjbg.png" alt="">
  <p>Во время выполнения этого кода, движок JavaScript создаёт глобальный контекст вызова, для того, чтобы выполнить глобальный код и когда он доходит до вызова функции first(), он создаёт новый контекст выполнения для этой функции и ставит её на вершину стека вызовов.</p>
  <p>Когда функция first() завершится, её стек выполнения удалится и начнется выполнение кода ниже. Так что оставшийся код в глобальной области видимости будет выполнен.</p>
  <p><i>Источник: <a href='https://medium.com/@stasonmars/%D0%BF%D0%BE%D0%BD%D0%B8%D0%BC%D0%B0%D0%B5%D0%BC-%D0%B7%D0%B0%D0%BC%D1%8B%D0%BA%D0%B0%D0%BD%D0%B8%D1%8F-%D0%B2-javascript-%D1%80%D0%B0%D0%B7-%D0%B8-%D0%BD%D0%B0%D0%B2%D1%81%D0%B5%D0%B3%D0%B4%D0%B0-c211805b6898'>medium.com</a></i></p>
</details>

<details>
  <summary>Что такое лексическое окружение?</summary>
  <br>
  <p>Каждый раз, когда движок JavaScript создаёт контекст выполнения, чтобы выполнить функцию или глобальный код, он также создаёт новое лексическое окружение, чтобы хранить переменную определенную в этой функции во время её выполнения.
  </p>
  <p>Лексическое окружение это структура данных, которая хранит информацию по идентификаторам переменных. Тут идентификатор обозначает имя переменных/функций, а переменная настоящий объект[включая тип функции] или примитивное значение.</p>
  <span>У лексического окружения есть два компонента: (1) запись в окружении и (2) отсылка к внешнему окружению.</span>
  <ul>
    <li>Запись в окружении(environment record) это место хранятся объявления переменной или функции.</li>
    <li>Отсылка к внешнему окружению (reference to the outer environment) означает то, что у него есть доступ к внешнему (родительскому) лексическому окружению. Этот компонент самый важный для понимания того, как работают замыкания.</li>
  </ul>
  <p><b>Обратите внимание</b> — когда функция выполняется, её контекст выполнения удаляется из стека, но её лексическое окружение может или не может быть удалено из памяти, в зависимости от того, ссылается ли на это лексическое окружение другое лексическое окружение.</p>
  <p><i>Источник: <a href='https://medium.com/@stasonmars/%D0%BF%D0%BE%D0%BD%D0%B8%D0%BC%D0%B0%D0%B5%D0%BC-%D0%B7%D0%B0%D0%BC%D1%8B%D0%BA%D0%B0%D0%BD%D0%B8%D1%8F-%D0%B2-javascript-%D1%80%D0%B0%D0%B7-%D0%B8-%D0%BD%D0%B0%D0%B2%D1%81%D0%B5%D0%B3%D0%B4%D0%B0-c211805b6898'>medium.com</a></i></p>
</details>

<details>
  <summary>Разница межды func expression и declaration?</summary>
  <p>Function Declaration - функция, объявленная в основном потоке кода.</p>
  <p>Function Expression - объявление функции в контексте какого-либо выражения, например присваивания.</p>
  <code>

    // Function Declaration
    sayHi("Вася"); // Привет, Вася

    function sayHi(name) {
      console.log( "Привет, " + name );
    }

    // Function Expression
    sayHi("Вася"); // ошибка!

    var sayHi = function(name) {
      console.log( "Привет, " + name );
    }

  </code>
  <p>Основное отличие между ними: функции, объявленные как Function Declaration, создаются интерпретатором до выполнения кода.</p>
  <p>Это из-за того, что JavaScript перед запуском кода ищет в нём Function Declaration (их легко найти: они не являются частью выражений и начинаются со слова function) и обрабатывает их. А Function Expression создаются в процессе выполнения выражения, в котором созданы, в данном случае – функция будет создана при операции присваивания sayHi = function...</p>
</details>

<details>
  <summary>Разница между обычными функциями и стрелочными</summary>
  <br>
  <ul>
    <li>
      <h3>this</h3>
      <p>Обыкновенные функции</p>
      <p>Внутри обыкновенной функции значение this динамическое (в зависимости от контекста исполнения).</p>
      <p>Динамический контекст означает, что значение this зависит от того как была вызвана функция. В JS существует 4е способа как ты можешь вызвать функцию.</p>
      <ul>
        <li>Во время обычного выполнения значение this эквивалентно глобальному объекту window.</li>
        <li>Во время выполнения функции объекта значением this является объект, у которого был вызван метод.</li>
        <li>Косвенный вызов используя myFunc.call(thisVal, arg1, ..., argN) или myFunc.apply(thisVal, [arg1, ..., argN]), значение this эквивалентно первому аргументу.</li>
        <li>Вызов с помощью конструктора используя ключевое слово new, значение this эквивалентно новосозданной сущности.</li>
      </ul>
      <p>Стрелочные функции</p>
      <p>Не имеет значения как она была вызвана, значение this внутри стрелочной функции всегда эквивалентно значения this внешней функции. Функция не создает собственный контекст исполнения, она использует внешний.</p>
    </li>
    <li>
      <h3>Конструкторы</h3>
      <p>Обыкновенные функции</p>
      <p>Обычная функция может легко создавать объекты, через конструктор new.</p>
      <p>Стрелочные функции</p>
      <p>Как следствие того, что стрелочные функции не имеют собственного this они не могут быть использованы для создания объектов.Если ты попытаешься вызвать стрелочную функцию с использованием ключевого слова new, JS кинет TypeError.</p>
    </li>
    <li>
      <h3>Объект arguments</h3>
      <p>Обыкновенные функции</p>
      <p>Внутри тела обыкновенной функции, существует специальный массив arguments содержащий список аргументов с которым функция была вызвана.</p>
      <code>

        function myFunction() {
          console.log(arguments);  
        }
          
        myFunction('a', 'b'); // { 0: 'a', 1: 'b'}

  </code>
      <p>Стрелочные функции</p>
      <p>В стрелочных функциях отсутствует специальное слово arguments.Опять, точно так же, как и со значение this массив arguments для стрелочных функций будет браться из внешней функции.</p>
      <code>

        function myRegularFunction() {
          const myArrowFunction = () => {
            console.log(arguments);
          }
          myArrowFunction('c', 'd');
        }
          
        myRegularFunction('a', 'b'); // { 0: 'a', 1: 'b' }

  </code>
    </li>
    <li>
      <h3>Неявный return</h3>
      <p>Обыкновенные функции</p>
      <p>Только использование выражения return возвращает результат выполнения функции.</p>
      <p>Стрелочные функции</p>
      <p>Если стрелочная функция содержит в теле одну инструкцию, и ты опустил фигурные скобки, тогда выражение будет возвращено автоматически.</p>
    </li>
    <li>
      <h3>Методы</h3>
      <p>Можно использовать стрелочные функции как методы, внутри класса.</p>
    </li>
  </ul>
  <p>Значение this внутри обыкновенной функции динамически зависит от контекста вызова. Собственный this внутри стрелочной функции отсутствует и она ссылается на this внешней функции. Массив arguments внутри обыкновенной функции содержит список аргументов функции. Стрелочная функция, не имеет массива arguments (но ты можешь использовать деструктуризацию, для иммитации аналога ...args).Если в стрелочной функции содержится одна инструкция, то ты можешь использовать неявный return, даже без использования ключевого слова return. Последнее в списке, но не по важности - ты можешь использовать синтаксис стрелочных функций для внутри класса. При этом в качестве this будет выступать объект класса.</p>
  <p><i>Источник: <a href='https://vc.ru/dev/133379-5-otlichiy-mezhdu-obychnymi-i-strelochnymi-funkciyami'>vc.ru</a></i></p>
</details>

<details>
  <br>
  <summary>Что такое this?</summary>
  <p>This — это ключевое слово, используемое в JavaScript, которое имеет особое значение, зависящее от контекста в котором оно применяется.</p>
  <h3>Ситуации, когда this указывает на объект window</h3>
  <p>Если вы попытаетесь обратиться к ключевому слову this в глобальной области видимости, оно будет привязано к глобальному контексту, то есть — к объекту window в браузере.</p>
  <h3>Использование this внутри объекта</h3>
  <p>Когда this используется внутри объекта, это ключевое слово ссылается на сам объект. Рассмотрим пример. Предположим, вы создали объект dog с методами и обратились в одном из его методов к this. Когда this используется внутри этого метода, это ключевое слово олицетворяет объект dog.</p>
  <h3>This и вложенные объекты</h3>
  <p>Применение this во вложенных объектах может создать некоторую путаницу. В подобных ситуациях стоит помнить о том, что ключевое слово this относиться к тому объекту, в методе которого оно используется. </p>
  <h3>Особенности стрелочных функций</h3>
  <p>Стрелочные функции ведут себя не так, как обычные функции. Вспомните: при обращении к this в методе объекта, этому ключевому слову соответствует объект, которому принадлежит метод. Однако это не относится к стрелочным функциям. Вместо этого, this в таких функциях относится к глобальному контексту (к объекту window).</p>
  <p><i>Источник: <a href='https://habr.com/ru/company/ruvds/blog/419371/'>habr.com</a></i></p>
</details>

<details>
  <summary>Что такое всплытие?</summary>
  
</details>
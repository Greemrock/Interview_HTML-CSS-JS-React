<details>
  <summary>Что такое DNS(Domain Name System)?</summary>
  <br>
  <p>Это глобальное распределенное хранилище ключей и значений. Сервера по всему миру могут предоставить вам значение по
    ключу, а если им неизвестен ключ, то они попросят помощи у другого сервера.</p>
  <p>Вы или ваш браузер запрашивает значение для ключа www.example.com, и получает в ответ 1.2.3.4.</p>
  <p><i>Источник: <a href='https://habr.com/ru/post/303446/'>habr.com</a></i></p>
</details>

<details>
  <summary>Как работают браузеры(HTTP)?</summary>

  Работа браузера в основном состоит из:
  - Разрешение DNS
  - HTTP-обмен
  - Рендеринг
  - Сброс и повтор
  ### Разрешение DNS
  Этот процесс помогает браузеру узнать, к какому серверу он должен подключиться, когда пользователь вводит URL.
    Браузер связывается с DNS-сервером и обнаруживает, что google.com соответствует набору цифр 216.58.207.110 —
    IP-адресу, к которому может подключиться браузер.
  ### HTTP-обмен
  Как только браузер определит, какой сервер будет обслуживать наш запрос, он установит с ним TCP-соединение и начнет
    HTTP-обмен.
  HTTP — это просто название самого популярного протокола для общения в сети, и браузеры в основном выбирают HTTP при общении с серверами. HTTP-обмен подразумевает, что клиент (наш браузер) отправляет запрос, а сервер присылает ответ.
  ### Рендеринг
  В теле ответа сервер включает представление запрашиваемого документа в соответствии с заголовком Content-Type. В нашем случае тип содержимого был установлен на text/html, поэтому мы ожидаем HTML-разметку в ответе — и именно ее мы и находим в теле документа.
  Это как раз тот момент, где браузер действительно проявляет свои способности. Он считывает и анализирует HTML-код, загружает дополнительные ресурсы, включенные в разметку (например, там могут быть указаны для подгрузки JavaScript-файлы или CSS-документы) и представляет их пользователю как можно скорее.

  Источник: [habr.com](https://habr.com/ru/company/edison/blog/432870/)
</details>

<details>
  <summary>Разница между LocalStorage, SessionStorage, Cookies</summary>
  <br>
  <span>Local Storage (локальное хранилище)</span>
  <ul>
    <li>Хранит данные бессрочно.</li>
    <li>Очищается только с помощью JavaScript или очистки кэша браузера.</li>
    <li>Хранит данные объёмом до 5 МБ, это самый большой объём из трёх вариантов хранилища.</li>
    <li>Не поддерживается старыми браузерами, например, IE 7 и ниже.</li>
    <li>Работает по правилу ограничения домена (same origin policy). То есть сохранённые данные доступны только для
      одного источника.</li>
  </ul>
  <br>
  <span>Session Storage (сессионное хранилище)</span>
  <ul>
    <li>Хранит данные, пока продолжается текущая сессия. Когда пользователь закрывает браузер, данные становятся
      недоступными.</li>
    <li>Используется контекст браузера верхнего уровня, поэтому каждая вкладка браузера хранит уникальные данные.</li>
    <li>Объём данных больше чем в Cookie.</li>
    <li>Не поддерживается старыми браузерами, например, IE 7 и ниже.</li>
  </ul>
  <br>
  <span>Cookie</span>
  <ul>
    <li>Хранит данные, которые можно передавать на сервер через заголовки.</li>
    <li>Локальное и сессионное хранилище доступны только на клиентской стороне.</li>
    <li>Срок хранения устанавливается при создании cookie.</li>
    <li>Объём данных не превышает 4 Кбайт.</li>
    <li>Cookie могут быть защищёнными, в этом случае их содержимое нельзя получить на стороне клиента. Это важно для
      аутентификации при хранении пользовательских токенов.</li>
  </ul>
  <p><i>Источник: <a
        href='https://ru.hexlet.io/blog/posts/lokalnoe-hranilische-vs-sessionnoe-hranilische-vs-cookie'>hexlet.io</a></i>
  </p>
</details>

<details>
  <summary>Что такое Big O?</summary>

Big O нотация нужна для описания сложности алгоритмов. Для этого используется понятие времени.

- O(1)

```javascript
const nums = [1, 2, 3, 4, 5];
const firstNumber = nums[0];
```

O(1) можно прочитать как «сложность порядка 1» (order 1), или «алгоритм выполняется за постоянное/константное время» (constant time).

- O(n)

```javascript
const nums = [1, 2, 3, 4, 5];
let sum = 0;
for (let num of nums) {
  sum += num;
}
```

Используя Big O нотацию: O(n), или «сложность порядка n (order n)». Так же такой тип алгоритмов называют «линейными» или что алгоритм «линейно масштабируется».

- O(n^2)

```javascript
const hasDuplicates = function (num) {
  //loop the list, our O(n) op
  for (let i = 0; i < nums.length; i++) {
    const thisNum = nums[i];
    //loop the list again, the O(n^2) op
    for (let j = 0; j < nums.length; j++) {
      //make sure we're not checking same number
      if (j !== i) {
        const otherNum = nums[j];
        //if there's an equal value, return
        if (otherNum === thisNum) return true;
      }
    }
  }
  //if we're here, no dups
  return false;
};
const nums = [1, 2, 3, 4, 5, 5];
hasDuplicates(nums); //true
```

Мы уже знаем что итерирование массива это O(n). У нас есть вложенный цикл, для каждого элемента мы еще раз итерируем — т.е. O(n^2) или «сложность порядка n квадрат».

Мышление в терминах Big O:

- Получение элемента коллекции это O(1). Будь то получение по индексу в массиве, или по ключу в словаре в нотации Big O это будет O(1)
- Перебор коллекции это O(n)
- Вложенные циклы по той же коллекции это O(n^2)
- Разделяй и властвуй (Divide and Conquer) всегда O(log n)
- Итерации которые используют Divide and Conquer это O(n log n)
</details>

<details>
  <summary>Какие структуры данных существуют?</summary>

Простыми словами, структура данных – это контейнер, который хранит информацию в определенном виде.

## Стек (вызовов) (Stack)

Стек следует принципу LIFO (Last In First Out — последним вошел, первым вышел).

## Очередь (кью) (Queue)

Очередь напоминает стек. Разница состоит в том, что очередь следует принципу FIFO (First In First Out — первым вошел, первым вышел). Когда вы стоите в очереди, первый в ней всегда будет первым.

    Порядок очередности (приоритет).
    Очередь имеет продвинутую версию. Присвойте каждому элементу приоритет, и элементы будут отсортированы соответствующим образом.

## Связный список (связанный, список узлов и ссылок или указателей) (Linked List)

Буквально, связный список — это цепочечная структура данных, где каждый узел состоит из двух частей: данных узла и указателя на следующий узел. Связный список и условный массив являются линейными структурами данных с сериализованным хранилищем. Отличия состоят в следующем:

<table>
  <tbody>
    <tr>
      <th>Критерий</th>
      <th>Массив</th>
      <th>Список</th>
    </tr>
    <tr>
      <td>Выделение памяти</td>
      <td>Статическое, происходит последовательно во время компиляции </td>
      <td>Динамическое, происходит асинхронно во время запуска (выполнения)</td>
    </tr>
    <tr>
      <td>Получение элементов</td>
      <td>Поиск по индексу, высокая скорость</td>
      <td>Поиск по всем узлам очереди, скорость менее высокая</td>
    </tr>
    <tr>
      <td>Добавление/удаление элементов</td>
      <td>В связи с последовательным и статическим распределением памяти скорость ниже</td>
      <td>В связи с динамическим распределением памяти скорость выше</td>
    </tr>
    <tr>
      <td>Структура</td>
      <td>Одно или несколько направлений</td>
      <td>Однонаправленный, двунаправленный или циклический</td>
    </tr>
  </tbody>
</table>

## Коллекция (значений) (Set)
Коллекция (множество) — одна из основных концепций математики: набор хорошо определенных и обособленных объектов. ES6 представил коллекцию, которая имеет некоторое сходство с массивом. Тем не менее, коллекция не допускает включения повторяющихся элементов и не содержит индексов.
## Хеш-таблица (таблица кэширования) (Hash Table)
Хеш-таблица — это структура данных, которая строится по принципу ключ-значение. Из-за высокой скорости поиска значений по ключам, она используется в таких структурах, как Map, Dictionary и Object. Как показано на рисунке, хеш-таблица имеет hash function, преобразующую ключи в список номеров, которые используются как имена (значения) ключей. Время поиска значения по ключу может достигать O(1). Одинаковые ключи должны возвращать одинаковые значения — в этом суть функции хэширования.
## Дерево (Tree)
Древовидная структура — это многослойная (многоуровневая) структура. Это также нелинейная структура, в отличие от массива, стека и очереди. Данная структура очень эффективна в части добавления и поиска элементов. 
## Граф (график) (Graph)
Граф, также известный как сеть (Network), представляет собой коллекцию связанных между собой узлов. Бывает два вида графов — ориентированный и неориентированный, в зависимости от того, имеют ли ссылки направление. Графы используются повсеместно, например, для расчета наилучшего маршрута в навигационных приложениях или для формирования списка рекомендаций в социальных сетях.
Графы могут быть представлены в виде списка или матрицы.
</details>

<details>
  <summary>Патерны</summary>

  Патерны проектирования — проверенный способ для решения проблем.
  
  Порождающие шаблоны (Creational): создание новых объектов.
  - Фабрика (Factory)
  - Синглтон(Singletion)

  Структурные шаблоны(Structural): упорядочивают объекты.
  - Model-View-Сontroller (MVC)
  - Model-View-ViewModel (MVVM):
    MVVM has four main blocks:
      - The View — UI слой где пользователи взаимодействуют с ним,
      - The ViewController — имеет доступ к ViewModel и обрабатывает ввод пользователя,
      - The ViewModel — имеет доступ к модели и обрабатывает бизнес-логику,
      - The Model — источник данных приложения
  - Декоратор(Decorator): расширяет функциональность
  - Фасад (Façade): используйте для создания простого интерфейса (абстрагирует функциональность, как например jQuery).

  Поведенческие (Behavioral): позволяет объектам наблюдать за объектами и быть оповещенными об изменениях.
  - Наблюдатель(Observer)
  - Посредник(Mediator): один объект контролирует сообщение между объектами, поэтому объекты не сообщаются друг с другом на прямую.
  - Команда(Command): инкапсулирует вызов метода в один объект.
  </details>
<br>

### Clean code

<details>
  <summary>Что такое SOLID?</summary>
  
  - Single responsibility (принцип единственной ответственности)
    обозначает, что каждый объект должен иметь одну обязанность и эта обязанность должна быть полностью инкапсулирована в класс. Все его сервисы должны быть направлены исключительно на обеспечение этой обязанности.

  - Open-closed (принцип открытости / закрытости)
    программные сущности (классы, модули, функции и т. п.) должны быть открыты для расширения, но закрыты для изменения. Это означает, что эти сущности могут менять свое поведение без изменения их исходного кода.
    
  - Принцип подстановки Барбары Лисков (Liskov substitution principle / LSP)
    Наследующий класс должен дополнять, а не замещать поведение базового класса.

  - Принцип разделения интерфейса (interface segregation principle / ISP)
    слишком «толстые» интерфейсы необходимо разделять на более маленькие и специфические, чтобы клиенты маленьких интерфейсов знали только о методах, которые необходимы им в работе. В итоге, при изменении метода интерфейса не должны меняться клиенты, которые этот метод не используют.
    
  - Принцип инверсии зависимостей (dependency inversion principle / DIP)
    модули верхних уровней не должны зависеть от модулей нижних уровней, а оба типа модулей должны зависеть от абстракций; сами абстракции не должны зависеть от деталей, а вот детали должны зависеть от абстракций.
    
    Например, мы реализуем хранение документов в веб-приложении. На первый взгляд, кажется логичным добавить зависимость от модулей работы с файловой системой непосредственно в класс, отвечающий за высокоуровневую работу с этими документами. Но в перспективе такая зависимость может создать проблемы — например, нам потребуется хранить данные не только на диске, но и в облаке. Если зависимость внедрена от реализации, то мы столкнёмся с необходимостью её переработки. Если же зависимость выведена на уровень абстракции (интерфейса), то нам будет достаточно реализовать функционал работы с облаком, соответствующий ранее созданному интерфейсу работы с файлами.

  Источник: [web-creator.ru](https://web-creator.ru/articles/solid)
</details>

<details>
  <summary>Что такое KISS (keep it simple, stupid)?</summary>

  KISS — это принцип проектирования и программирования, при котором простота системы декларируется в качестве основной цели или ценности. 

  В программировании следование принципу KISS можно описать так:

  - не имеет смысла беспредельно увеличивать уровень абстракции, надо уметь вовремя остановиться;
  - бессмысленно закладывать в проект избыточные функции «про запас», которые может быть когда-нибудь кому-либо понадобятся (тут скорее правильнее подход согласно принципу YAGNI);
  - не стоит подключать огромную библиотеку, если вам от неё нужна лишь пара функций;
  - декомпозиция чего-то сложного на простые составляющие — это архитектурно верный подход (тут KISS перекликается с DRY);
  - абсолютная математическая точность или предельная детализация нужны не всегда — большинство систем создаются не для запуска космических шаттлов, данные можно и нужно обрабатывать с той точностью, которая достаточна для качественного решения задачи, а детализацию выдавать в нужном пользователю объёме, а не в максимально возможном объёме.

  Источник: [web-creator.ru](https://web-creator.ru/articles/kiss)
</details>

<details>
  <summary>Что такое YAGNI (You Ain’t Gonna Need It)?</summary>

  Если упрощенно, то следование данному принципу заключается в том, что возможности, которые не описаны в требованиях к системе, просто не должны реализовываться.

  Источник: [web-creator.ru](https://web-creator.ru/articles/yagni)
</details>

<details>
  <summary>Что такое DRY (Don’t repeat yourself)?</summary>

  Не повторяйте написанный код!

  Источник: [web-creator.ru](https://web-creator.ru/articles/yagni)
</details>
<br>

### CSS

<details>
  <summary>Что такое селекторы?</summary>
  <br>
  <p>Селектор определяет, к какому элементу применять то или иное CSS-правило.</p>
  <span>Основных видов селекторов всего несколько:</span>
  <ul>
    <li>* – любые элементы.</li>
    <li>div – элементы с таким тегом.</li>
    <li>#id – элемент с данным id.</li>
    <li>.class – элементы с таким классом.</li>
    <li>[name="value"] – селекторы на атрибут</li>
    <li>:visited – «псевдоклассы», остальные разные условия на элемент</li>
  </ul>
  <br>
  <p><i>Источник: <a href='https://learn.javascript.ru/css-selectors'>javascript.ru</a></i></p>
</details>

<details>
  <summary>Что такое спецефичность селекторов?</summary>
  <br>
  <p>Специфичность - это способ, с помощью которого браузеры определяют, какие значения свойств CSS наиболее
    соответствуют элементу и, следовательно, будут применены.</p>
  <span>Спецефичность селекторов:</span>
  <table>
    <tbody>
      <tr>
        <td>Селектор тега:</td>
        <td>1</td>
      </tr>
      <tr>
        <td>Селектор класса:</td>
        <td>10</td>
      </tr>
      <tr>
        <td>Селектор ID:</td>
        <td>100</td>
      </tr>
      <tr>
        <td>Inline-стиль:</td>
        <td>1000</td>
      </tr>
    </tbody>
  </table>
  <p><i>Источник: <a href='https://developer.mozilla.org/ru/docs/Web/CSS/Specificity'>developer.mozilla.org</a></i></p>
</details>

<details>
  <summary>Что такое вложенные селекторы?</summary>
  <br>
  <p>В HTML можно вписать одни теги в другие. В CSS мы можем выбирать те теги, которые вложены в какой-либо тег. Для
    этого используется конструкция вложенных селекторов (A B). Например, мы можем задать стили для всех em, которые
    находятся в тегах div.</p>
  <code>
    #example em {
      color: #cc4d4d;
    }
  </code>
  <p><i>Источник: <a href='https://developer.mozilla.org/ru/docs/Web/CSS/Specificity'>developer.mozilla.org</a></i></p>
</details>

<details>
  <summary>Что такое семантическая вёрстка и зачем она нужна?</summary>
  <br>
  <ul>
    <li>Чтобы сделать сайт доступным. Зрячие пользователи могут без проблем с первого взгляда понять, где какая часть
      страницы находится — где заголовок, списки или изображения. Для незрячих или плохо видящих основной инструмент для
      просмотра сайтов не браузер, который отрисовывает страницу, а скринридер, который читает текст со страницы вслух.
    </li>
    <li>Чтобы сайт был выше в поисковиках. Наличие семантической разметки страниц помогает поисковым ботам лучше
      понимать, что находится на странице, и в зависимости от этого ранжировать сайты в поисковой выдаче.</li>
    <li>Tags: article, section, aside, nav, header, main, footer, h1-h6, ul...</li>
</details>

<details>
  <summary>Position</summary>
  <ul>
    <li>
      <span>static</span>
      <p>static ещё называют не позиционированным(отпозиционированы статически, то есть никак).</p>>
    </li>
    <li>
      <span>relative</span>
      <p>Относительное позиционирование сдвигает элемент относительно его обычного положения.</p>>
    </li>
    <li>
      <span>absolute</span>
      <p>Абсолютное позиционирование делает две вещи: Элемент исчезает с того места, где он должен быть и позиционируется заново и Координаты top/bottom/left/right для нового местоположения отсчитываются от ближайшего позиционированного родителя.</p>>
    </li>
    <li>
      <span>fixed</span>
      <p>Позиционирует объект точно так же, как absolute, но относительно window.</p>>
      <p>Когда страницу прокручивают, фиксированный элемент остаётся на своём месте и не прокручивается вместе со страницей.</p>
    </li>
    <li>
      <span>sticky </span>
      <p>sticky может перемещаться только в пределах контейнера, в котором находится.</p>>
    </li>
  </ul>
</details>

<details>
  <summary>display</summary>
  <ul>
    <li>
      <span>none</span>
      <p>Элемент не показывается, вообще. Как будто его и нет.</p>
    </li>
    <li>
      <span>block</span>
      <p>Блочные элементы располагаются один над другим, вертикально (если нет особых свойств позиционирования, например float).</p>
      <p>Блок стремится расшириться на всю доступную ширину. Можно указать ширину и высоту явно.</p>
    </li>
    <li>
      <span>inline</span>
      <p>Блочные элементы располагаются один над другим, вертикально (если нет особых свойств позиционирования, например float).
      </p>
      <p>Блок стремится расшириться на всю доступную ширину. Можно указать ширину и высоту явно.</p>
    </li>
    <li>
      <span>inline-block</span>
      <p>Это значение – означает элемент, который продолжает находиться в строке (inline), но при этом может иметь важные свойства блока.</p>
    </li>
    <li>
      <span>table-*</span>
      <p>Современные браузеры (IE8+) позволяют описывать таблицу любыми элементами, если поставить им соответствующие значения display.</p>
    </li>
    <li>
      <span>flex</span>
    </li>
    <li>
      <span>grid</span>
    </li>
  </ul>
</details>
<br>

### JavaScript

<details>
  <summary>Что такое Hoisting?</summary>
  <br>
  <p>Поднятие или hoisting — это механизм в JavaScript, в котором переменные и объявления функций, передвигаются вверх своей области видимости перед тем, как код будет выполнен.</p>
  <p>JavaScript сначала объявляет, а уже затем инициализирует наши переменные.</p>
  <ul>
    <li>
      <span>var</span>
      <p>Областью видимости переменной, объявленной через var, является её настоящий контекст выполнения.</p>

  ```javascript
    console.log(hoist); // Вывод: undefined
    var hoist = 'The variable has been hoisted.';
    function hoist() {
      console.log(message);
      message='Hoisting is all the rage!'
    }
    hoist(); // Вывод: undefined
  ```
  </li>
  <li>
    <span>let</span>
    <p>Переменные объявленные через let заключены в область видимости блока, а не функции.</p>
    <p>Вкратце, это просто говорит о том, что область видимости переменной привязана к блоку, в котором она объявлена, а не к функции в которой она объявлена.</p>
  
  ```javascript
    console.log(hoist); // Вывод: ReferenceError: hoist is not defined
    ...
    let hoist = 'The variable has been hoisted.';
  ```
  </li>
  <li>
    <span>const</span>
    <p>Const была представлена в es6 для того, чтобы можно было сделать неизменные переменные.</p>
  </li>
  <p>Переменные объявленные с let и const остаются неинициализированными в начале выполнения, в то время как переменные объявленные с var инициализируются со значением undefined.</p>
  <br>
  <b>Поднятие функций</b>
  <span>Объявленные функции</span>
  <p>Такие функции полностью поднимаются вверх кода.</p>

  ```javascript
    hoisted(); // Вывод: "This function has been hoisted."
    function hoisted() {
      console.log('This function has been hoisted.');
    };
  ```
  <p>Функциональные выражения, однако, не поднимаются.</p>
  <code>

  ```javascript
  expression(); //Вывод: "TypeError: expression is not a function
  var expression = function() {
    console.log('Will this work?');
  };
  ```

  </code>
  <p>1. Используя es5 переменную var, попытки использования необъявленных переменных приведут к тому, что переменной будет назначено значение undefined при «поднятии».</p>
  <p>2. Используя переменные es6 let и const, использование переменных приведет к Reference Error, потому что переменная останется неинициализированной при выполнении.</p>
  <p><i>Источник: <a href='https://medium.com/@stasonmars/%D1%80%D0%B0%D0%B7%D0%B1%D0%B8%D1%80%D0%B0%D0%B5%D0%BC%D1%81%D1%8F-%D1%81-%D0%BF%D0%BE%D0%B4%D0%BD%D1%8F%D1%82%D0%B8%D0%B5%D0%BC-hoisting-%D0%B2-javascript-7d2d27bc51f1'>medium.com</a></i></p>
</details>

<details>
  <summary>Что такое Temporal Dead Zone?</summary>

  Термин, описывающий состояние, в котором переменные недоступны.
  
</details>

<details>
  <br>
  <summary>Что такое this?</summary>
  <p>This — это ключевое слово, используемое в JavaScript, которое имеет особое значение, зависящее от контекста в котором оно применяется.</p>
  <h3>Ситуации, когда this указывает на объект window</h3>
  <p>Если вы попытаетесь обратиться к ключевому слову this в глобальной области видимости, оно будет привязано к глобальному контексту, то есть — к объекту window в браузере.</p>
  <h3>Использование this внутри объекта</h3>
  <p>Когда this используется внутри объекта, это ключевое слово ссылается на сам объект. Рассмотрим пример. Предположим, вы создали объект dog с методами и обратились в одном из его методов к this. Когда this используется внутри этого метода, это ключевое слово олицетворяет объект dog.</p>
  <h3>This и вложенные объекты</h3>
  <p>Применение this во вложенных объектах может создать некоторую путаницу. В подобных ситуациях стоит помнить о том, что ключевое слово this относиться к тому объекту, в методе которого оно используется. </p>
  <h3>Особенности стрелочных функций</h3>
  <p>Стрелочные функции ведут себя не так, как обычные функции. Вспомните: при обращении к this в методе объекта, этому ключевому слову соответствует объект, которому принадлежит метод. Однако это не относится к стрелочным функциям. Вместо этого, this в таких функциях относится к глобальному контексту (к объекту window).</p>
  <p><i>Источник: <a href='https://habr.com/ru/company/ruvds/blog/419371/'>habr.com</a></i></p>
</details>

<details>
<summary>Apply, call, bind. Для чего используются? В чем отличия?</summary>

- _call_

Метод call() вызывает функцию с указанным значением this и индивидуально предоставленными аргументами. Вы можете присваивать различные объекты this при вызове существующей функции. this ссылается на текущий объект, вызвавший объект. С помощью call вы можете написать метод один раз, а затем наследовать его в других объектах, без необходимости переписывать метод для каждого нового объекта.

```javascript
function showFullName() {
  alert(this.firstName + " " + this.lastName);
}

const user = {
  firstName: "Василий",
  lastName: "Петров",
};

// функция вызовется с this=user
showFullName.call(user); // "Василий Петров"
```

- _apply_

Метод apply() вызывает функцию с указанным значением this и аргументами, предоставленными в виде массива (либо массивоподобного объекта). Вы можете присваивать различные объекты this при вызове существующей функции. this ссылается на текущий объект, вызывающий объект. С помощью apply() вы можете написать метод один раз, а затем наследовать его в других объектах без необходимости переписывать метод для каждого нового объекта.

```javascript
//эти две строчки сработают одинаково:
showFullName.call(user, "firstName", "surname");
showFullName.apply(user, ["firstName", "surname"]);
```

```javascript
var arr = [];
arr.push(1);
arr.push(5);
arr.push(2);

// получить максимум из элементов arr
alert(Math.max.apply(null, arr)); // 5
```

Преимущество apply() перед call() отчётливо видно, когда мы формируем массив аргументов динамически.

- _bind_

Метод bind() создаёт новую функцию, которая при вызове устанавливает в качестве контекста выполнения this предоставленное значение. В метод также передаётся набор аргументов, которые будут установлены перед переданными в привязанную функцию аргументами при её вызове.

```javascript
// Пример потери контекста
var user = {
  firstName: "Вася",
  sayHi: function () {
    alert(this.firstName);
  },
};

setTimeout(user.sayHi, 1000); // undefined (не Вася!)
```

```javascript
// привязка контекста
var user = {
  firstName: "Вася",
  sayHi: function () {
    alert(this.firstName);
  },
};

setTimeout(user.sayHi.bind(user), 1000); // Вася
```

Вызов bind часто используют для привязки функции к контексту, чтобы затем присвоить её в обычную переменную и вызывать уже без явного указания объекта.

- фундаментальное различие между этими методами заключается в том, что функция call() принимает список аргументов, в то время, как функция apply() - одиночный массив аргументов. Методы call/apply вызывают функцию с заданным контекстом и аргументами. А bind не вызывает функцию. Он только возвращает «обёртку», которую мы можем вызвать позже, и которая передаст вызов в исходную функцию, с привязанным контекстом.

Подробнее:

https://learn.javascript.ru/call-apply

https://learn.javascript.ru/bind

</details>

<details>
  <summary>Методы массива, перебирающие элементы массива</summary>

- _forEach_
  Метод «Array.prototype.forEach(callback[, thisArg])» используется для перебора массива.
  Он для каждого элемента массива вызывает функцию callback.
  Этой функции он передаёт три параметра callback(item, i, arr):

item – очередной элемент массива.

i – его номер.

arr – массив, который перебирается.

Например:

```javascript
let arr = ["Яблоко", "Апельсин", "Груша"];

arr.forEach(function (item, i, arr) {
  alert(i + ": " + item + " (массив:" + arr + ")");
});
```

Второй, необязательный аргумент forEach позволяет указать контекст this для callback.
Метод forEach ничего не возвращает, его используют только для перебора, как более «элегантный» вариант, чем обычный цикл for.

- _filter_
  Метод «Array.prototype.filter(callback[, thisArg])» используется для фильтрации массива через функцию.
  Он создаёт новый массив, в который войдут только те элементы arr, для которых вызов callback(item, i, arr) возвратит true.

Например:

```javascript
let arr = [1, -1, 2, -2, 3];

let positiveArr = arr.filter(function (number) {
  return number > 0;
});

alert(positiveArr); // 1,2,3
```

- _map_
  Метод «Array.prototype.map(callback[, thisArg])» используется для трансформации массива.
  Он создаёт новый массив, который будет состоять из результатов вызова callback(item, i, arr) для каждого элемента arr.

Например:

```javascript
let names = ["HTML", "CSS", "JavaScript"];

let nameLengths = names.map(function (name) {
  return name.length;
});

// получили массив с длинами
alert(nameLengths); // 4,3,10
```

- _every/some_

Эти методы используются для проверки массива.

Метод «Array.prototype.every(callback[, thisArg])» возвращает true, если вызов callback вернёт true для каждого элемента arr.
Метод «Array.prototype.some(callback[, thisArg])» возвращает true, если вызов callback вернёт true для какого-нибудь элемента arr.

```javascript
let arr = [1, -1, 2, -2, 3];

function isPositive(number) {
  return number > 0;
}

alert(arr.every(isPositive)); // false, не все положительные
alert(arr.some(isPositive)); // true, есть хоть одно положительное
```

- _reduce/reduceRight_

Метод «Array.prototype.reduce(callback[, initialValue])» используется для последовательной обработки каждого элемента массива с сохранением промежуточного результата.
Метод reduce используется для вычисления на основе массива какого-либо единого значения, иначе говорят «для свёртки массива». Чуть далее мы разберём пример для вычисления суммы.
Он применяет функцию callback по очереди к каждому элементу массива слева направо, сохраняя при этом промежуточный результат.

Аргументы функции callback(previousValue, currentItem, index, arr):

previousValue – последний результат вызова функции, он же «промежуточный результат».
currentItem – текущий элемент массива, элементы перебираются по очереди слева-направо.

index – номер текущего элемента.

arr – обрабатываемый массив.

Кроме callback, методу можно передать «начальное значение» – аргумент initialValue. Если он есть, то на первом вызове значение previousValue будет равно initialValue, а если у reduce нет второго аргумента, то оно равно первому элементу массива, а перебор начинается со второго.

Пример:

```javascript
let arr = [1, 2, 3, 4, 5];

// для каждого элемента массива запустить функцию,
// промежуточный результат передавать первым аргументом далее
let result = arr.reduce(function (sum, current) {
  return sum + current;
}, 0);

alert(result); // 15
```

При первом запуске sum – исходное значение, с которого начинаются вычисления, равно нулю (второй аргумент reduce).
Сначала анонимная функция вызывается с этим начальным значением и первым элементом массива, результат запоминается и передаётся в следующий вызов, уже со вторым аргументом массива, затем новое значение участвует в вычислениях с третьим аргументом и так далее.

Подробнее:

https://learn.javascript.ru/array-iteration

https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach

https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/filter

https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/map

https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/every

https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/some

https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce

</details>

<details>
  <summary>Promises</summary>

Для того чтобы поиграться с запросами, можно использовать открытый API http://jsonplaceholder.typicode.com/

Объект Promise (обещание) используется для отложенных и асинхронных вычислений. Promise может находиться в трёх состояниях:

- ожидание (pending): начальное состояние, не выполнено и не отклонено.
- выполнено (fulfilled): операция завершена успешно.
- отклонено (rejected): операция завершена с ошибкой.

```javascript
// Создаётся объект promise
let promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    // переведёт промис в состояние fulfilled с результатом "result"
    resolve("result");
  }, 1000);
});

// promise.then навешивает обработчики на успешный результат или ошибку
promise.then(
  (result) => {
    // первая функция-обработчик - запустится при вызове resolve
    alert("Fulfilled: " + result); // result - аргумент resolve
  },
  (error) => {
    // вторая функция - запустится при вызове reject
    alert("Rejected: " + error); // error - аргумент reject
  }
);
```

https://learn.javascript.ru/promise
https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Promise

</details>

<details>
  <summary>Prototype. Отличия proto от prototype. Пример наследования</summary>
  
Объекты в JavaScript можно организовать в цепочки так, чтобы свойство, не найденное в одном объекте, автоматически искалось бы в другом.
Связующим звеном выступает специальное свойство __proto__.
Если один объект имеет специальную ссылку __proto__ на другой объект, то при чтении свойства из него, если свойство отсутствует в самом объекте, оно ищется в объекте __proto__.
```javascript
var animal = {
  eats: true
};
var rabbit = {
  jumps: true
};

rabbit.**proto** = animal;

// в rabbit можно найти оба свойства
console.log( rabbit.jumps ); // true
console.log( rabbit.eats ); // true
```
Объект, на который указывает ссылка __proto__, называется «прототипом». В данном случае получилось, что animal является прототипом для rabbit.
У объекта, который является __proto__, может быть свой __proto__, у того – свой, и так далее. При этом свойства будут искаться по цепочке.
__proto__ не работает в IE10.
К счастью, в JavaScript с древнейших времён существует альтернативный, встроенный в язык и полностью кросс-браузерный способ.
Чтобы новым объектам автоматически ставить прототип, конструктору ставится свойство prototype.
При создании объекта через new, в его прототип __proto__ записывается ссылка из prototype функции-конструктора.

Например, код ниже полностью аналогичен предыдущему, но работает всегда и везде:

```javascript
let animal = {
  eats: true
};

function Rabbit(name) {
  this.name = name;
}

Rabbit.prototype = animal;

let rabbit = new Rabbit("Кроль"); //  rabbit.__proto__ == animal

alert( rabbit.eats ); // true
```

Установка Rabbit.prototype = animal буквально говорит интерпретатору следующее: "При создании объекта через new Rabbit запиши ему **proto** = animal".
Свойство prototype имеет смысл только у конструктора
Свойство с именем prototype можно указать на любом объекте, но особый смысл оно имеет, лишь если назначено функции-конструктору.
Само по себе, без вызова оператора new, оно вообще ничего не делает, его единственное назначение – указывать **proto** для новых объектов.

Пример наследования:

```javascript
// 1. Конструктор Animal
function Animal(name) {
  this.name = name;
  this.speed = 0;
}

// 1.1. Методы -- в прототип

Animal.prototype.stop = function () {
  this.speed = 0;
  alert(this.name + " стоит");
};

Animal.prototype.run = function (speed) {
  this.speed += speed;
  alert(this.name + " бежит, скорость " + this.speed);
};

// 2. Конструктор Rabbit
function Rabbit(name) {
  this.name = name;
  this.speed = 0;
  1;
}

// 2.1. Наследование
Rabbit.prototype = Object.create(Animal.prototype);
Rabbit.prototype.constructor = Rabbit;

// 2.2. Методы Rabbit
Rabbit.prototype.jump = function () {
  this.speed++;
  alert(this.name + " прыгает, скорость " + this.speed);
};
```

Подробнее:

http://learn.javascript.ru/class-inheritance

http://learn.javascript.ru/prototype

http://learn.javascript.ru/new-prototype

</details>

<details>
  <summary>Что такое ЗАМЫКАНИЕ?</summary>
  <br>
  <p>Замыкание это функция у которой есть доступ к своей внешней функции по области видимости, даже после того, как внешняя функция прекратилась. Это говорит о том, что замыкание может запоминать и получать доступ к переменным, и аргументам своей внешней функции, даже после того, как та прекратит выполнение.</p>
  <code>

    function getCounter() {
      let counter = 0;
      return function() {
        return counter++;
      }
    }
    let count = getCounter();
    console.log(count());  // 0
    console.log(count());  // 1
    console.log(count());  // 2

  </code>
  <p>Мы храним анонимную внутреннюю функцию, возвращенную функцией getCounter в переменной count. Так как функция сount теперь замыкание, она может получать доступ к переменной counter в функции getCounter, даже после того, как та завершится.</p>
  <p>Но обратите внимание, что значение counter не сбрасывается до 0 при каждом вызове count, как вроде бы она должна делать.
  </p>
  <p>Так происходит, потому что при каждом вызове count(), создаётся новая область видимости, но есть только одна область видимости, созданная для getCounter, так как переменная counter объявлена в области видимости getCounter(), она увеличится при каждом вызове функции count, вместо того, чтобы сброситься до 0.</p>
  <p><i>Источник: <a href='https://medium.com/@stasonmars/%D0%BF%D0%BE%D0%BD%D0%B8%D0%BC%D0%B0%D0%B5%D0%BC-%D0%B7%D0%B0%D0%BC%D1%8B%D0%BA%D0%B0%D0%BD%D0%B8%D1%8F-%D0%B2-javascript-%D1%80%D0%B0%D0%B7-%D0%B8-%D0%BD%D0%B0%D0%B2%D1%81%D0%B5%D0%B3%D0%B4%D0%B0-c211805b6898'>medium.com</a></i></p>
</details>

<details>
  <summary>Что такое контекст выполнения?</summary>
  <br>
  <p>Это абстрактная среда, в которой JavaScript код оценивается и выполняется. Когда выполняется “глобальный” код, он выполняется внутри глобального контекста выполнения, а код функции выполняется внутри контекста выполнения функции.</p>
  <img src="https://miro.medium.com/max/875/1*huMb5-_MmM8zkFVnchsjbg.png" alt="">
  <p>Во время выполнения этого кода, движок JavaScript создаёт глобальный контекст вызова, для того, чтобы выполнить глобальный код и когда он доходит до вызова функции first(), он создаёт новый контекст выполнения для этой функции и ставит её на вершину стека вызовов.</p>
  <p>Когда функция first() завершится, её стек выполнения удалится и начнется выполнение кода ниже. Так что оставшийся код в глобальной области видимости будет выполнен.</p>
  <p><i>Источник: <a href='https://medium.com/@stasonmars/%D0%BF%D0%BE%D0%BD%D0%B8%D0%BC%D0%B0%D0%B5%D0%BC-%D0%B7%D0%B0%D0%BC%D1%8B%D0%BA%D0%B0%D0%BD%D0%B8%D1%8F-%D0%B2-javascript-%D1%80%D0%B0%D0%B7-%D0%B8-%D0%BD%D0%B0%D0%B2%D1%81%D0%B5%D0%B3%D0%B4%D0%B0-c211805b6898'>medium.com</a></i></p>
</details>

<details>
  <summary>Что такое лексическое окружение?</summary>
  <br>
  <p>Каждый раз, когда движок JavaScript создаёт контекст выполнения, чтобы выполнить функцию или глобальный код, он также создаёт новое лексическое окружение, чтобы хранить переменную определенную в этой функции во время её выполнения.
  </p>
  <p>Лексическое окружение это структура данных, которая хранит информацию по идентификаторам переменных. Тут идентификатор обозначает имя переменных/функций, а переменная настоящий объект[включая тип функции] или примитивное значение.</p>
  <span>У лексического окружения есть два компонента: (1) запись в окружении и (2) отсылка к внешнему окружению.</span>
  <ul>
    <li>Запись в окружении(environment record) это место хранятся объявления переменной или функции.</li>
    <li>Отсылка к внешнему окружению (reference to the outer environment) означает то, что у него есть доступ к внешнему (родительскому) лексическому окружению. Этот компонент самый важный для понимания того, как работают замыкания.</li>
  </ul>
  <p><b>Обратите внимание</b> — когда функция выполняется, её контекст выполнения удаляется из стека, но её лексическое окружение может или не может быть удалено из памяти, в зависимости от того, ссылается ли на это лексическое окружение другое лексическое окружение.</p>
  <p><i>Источник: <a href='https://medium.com/@stasonmars/%D0%BF%D0%BE%D0%BD%D0%B8%D0%BC%D0%B0%D0%B5%D0%BC-%D0%B7%D0%B0%D0%BC%D1%8B%D0%BA%D0%B0%D0%BD%D0%B8%D1%8F-%D0%B2-javascript-%D1%80%D0%B0%D0%B7-%D0%B8-%D0%BD%D0%B0%D0%B2%D1%81%D0%B5%D0%B3%D0%B4%D0%B0-c211805b6898'>medium.com</a></i></p>
</details>

<details>
  <summary>Разница межды func expression и declaration?</summary>
  <p>Function Declaration - функция, объявленная в основном потоке кода.</p>
  <p>Function Expression - объявление функции в контексте какого-либо выражения, например присваивания.</p>
  <code>

    // Function Declaration
    sayHi("Вася"); // Привет, Вася

    function sayHi(name) {
      console.log( "Привет, " + name );
    }

    // Function Expression
    sayHi("Вася"); // ошибка!

    var sayHi = function(name) {
      console.log( "Привет, " + name );
    }

  </code>
  <p>Основное отличие между ними: функции, объявленные как Function Declaration, создаются интерпретатором до выполнения кода.</p>
  <p>Это из-за того, что JavaScript перед запуском кода ищет в нём Function Declaration (их легко найти: они не являются частью выражений и начинаются со слова function) и обрабатывает их. А Function Expression создаются в процессе выполнения выражения, в котором созданы, в данном случае – функция будет создана при операции присваивания sayHi = function...</p>
</details>

<details>
  <summary>Разница между обычными функциями и стрелочными</summary>
  <br>
  <ul>
    <li>
      <h3>this</h3>
      <p>Обыкновенные функции</p>
      <p>Внутри обыкновенной функции значение this динамическое (в зависимости от контекста исполнения).</p>
      <p>Динамический контекст означает, что значение this зависит от того как была вызвана функция. В JS существует 4е способа как ты можешь вызвать функцию.</p>
      <ul>
        <li>Во время обычного выполнения значение this эквивалентно глобальному объекту window.</li>
        <li>Во время выполнения функции объекта значением this является объект, у которого был вызван метод.</li>
        <li>Косвенный вызов используя myFunc.call(thisVal, arg1, ..., argN) или myFunc.apply(thisVal, [arg1, ..., argN]), значение this эквивалентно первому аргументу.</li>
        <li>Вызов с помощью конструктора используя ключевое слово new, значение this эквивалентно новосозданной сущности.</li>
      </ul>
      <p>Стрелочные функции</p>
      <p>Не имеет значения как она была вызвана, значение this внутри стрелочной функции всегда эквивалентно значения this внешней функции. Функция не создает собственный контекст исполнения, она использует внешний.</p>
    </li>
    <li>
      <h3>Конструкторы</h3>
      <p>Обыкновенные функции</p>
      <p>Обычная функция может легко создавать объекты, через конструктор new.</p>
      <p>Стрелочные функции</p>
      <p>Как следствие того, что стрелочные функции не имеют собственного this они не могут быть использованы для создания объектов.Если ты попытаешься вызвать стрелочную функцию с использованием ключевого слова new, JS кинет TypeError.</p>
    </li>
    <li>
      <h3>Объект arguments</h3>
      <p>Обыкновенные функции</p>
      <p>Внутри тела обыкновенной функции, существует специальный массив arguments содержащий список аргументов с которым функция была вызвана.</p>
      <code>

        function myFunction() {
          console.log(arguments);
        }

        myFunction('a', 'b'); // { 0: 'a', 1: 'b'}

  </code>
      <p>Стрелочные функции</p>
      <p>В стрелочных функциях отсутствует специальное слово arguments.Опять, точно так же, как и со значение this массив arguments для стрелочных функций будет браться из внешней функции.</p>
      <code>

        function myRegularFunction() {
          const myArrowFunction = () => {
            console.log(arguments);
          }
          myArrowFunction('c', 'd');
        }

        myRegularFunction('a', 'b'); // { 0: 'a', 1: 'b' }

  </code>
    </li>
    <li>
      <h3>Неявный return</h3>
      <p>Обыкновенные функции</p>
      <p>Только использование выражения return возвращает результат выполнения функции.</p>
      <p>Стрелочные функции</p>
      <p>Если стрелочная функция содержит в теле одну инструкцию, и ты опустил фигурные скобки, тогда выражение будет возвращено автоматически.</p>
    </li>
    <li>
      <h3>Методы</h3>
      <p>Можно использовать стрелочные функции как методы, внутри класса.</p>
    </li>
  </ul>
  <p>Значение this внутри обыкновенной функции динамически зависит от контекста вызова. Собственный this внутри стрелочной функции отсутствует и она ссылается на this внешней функции. Массив arguments внутри обыкновенной функции содержит список аргументов функции. Стрелочная функция, не имеет массива arguments (но ты можешь использовать деструктуризацию, для иммитации аналога ...args).Если в стрелочной функции содержится одна инструкция, то ты можешь использовать неявный return, даже без использования ключевого слова return. Последнее в списке, но не по важности - ты можешь использовать синтаксис стрелочных функций для внутри класса. При этом в качестве this будет выступать объект класса.</p>
  <p><i>Источник: <a href='https://vc.ru/dev/133379-5-otlichiy-mezhdu-obychnymi-i-strelochnymi-funkciyami'>vc.ru</a></i></p>
</details>

<details>
  <summary>Что такое рекурсия?</summary>

Рекурсия – это термин в программировании, означающий вызов функцией самой себя. Рекурсивные функции могут быть использованы для элегантного решения определённых задач.

Когда функция вызывает саму себя, это называется шагом рекурсии. База рекурсии – это такие аргументы функции, которые делают задачу настолько простой, что решение не требует дальнейших вложенных вызовов.

Рассмотрим два способа её реализации.

Итеративный способ: цикл for:

```javascript
function pow(x, n) {
  let result = 1;

  // умножаем result на x n раз в цикле
  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}

alert(pow(2, 3)); // 8
```

Рекурсивный способ: упрощение задачи и вызов функцией самой себя:

```javascript
function pow(x, n) {
  if (n == 1) {
    return x;
  } else {
    return x * pow(x, n - 1);
  }
}

alert(pow(2, 3)); // 8
```

</details>

<details>
  <summary>Всплытие и перехват событий</summary>

Основной принцип всплытия:

При наступлении события обработчики сначала срабатывают на самом вложенном элементе, затем на его родителе, затем выше и так далее, вверх по цепочке вложенности.

![](https://learn.javascript.ru/article/event-bubbling/event-order-bubbling.png)

Самый глубокий элемент, который вызывает событие, называется «целевым» или «исходным» элементом и доступен как `event.target`.

Для остановки всплытия нужно вызвать метод `event.stopPropagation()`.

`stopPropagation` препятствует продвижению события дальше, но на текущем элементе все обработчики отработают.

Для того, чтобы не только предотвратить всплытие, но и останавить обработку событий на текущем элементе используется метод `event.stopImmediatePropagation()`

В современном стандарте, кроме "всплытия" событий, предусмотрено ещё и "погружение" (или "захват").

![](https://mdn.mozillademos.org/files/14075/bubbling-capturing.png)

Откройте данный пример: 

[исходный код](https://github.com/mdn/learning-area/blob/master/javascript/building-blocks/events/show-video-box.html)

[пример](http://mdn.github.io/learning-area/javascript/building-blocks/events/show-video-box.html)

```javascript
video.onclick = function(e) {
  e.stopPropagation();
  video.play();
};
```
Подробнее:

[developer.mozilla.org](https://developer.mozilla.org/ru/docs/Learn/JavaScript/Building_blocks/%D0%A1%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D1%8F#%D0%92%D1%81%D0%BF%D0%BB%D1%8B%D1%82%D0%B8%D0%B5_%D0%B8_%D0%BF%D0%B5%D1%80%D0%B5%D1%85%D0%B2%D0%B0%D1%82_%D1%81%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D0%B9)

https://learn.javascript.ru/event-bubbling
</details>

<details>
  <summary>Что такое EventLoop?</summary>

  ![](https://joprblob.azureedge.net/site/blog/8e147efe-422d-42c3-bb51-61ca50d660dc/event.png)

</details>

<br>

### React

<details>
  <summary>Что такое REACT?</summary>

  React — это JavaScript-библиотека для создания пользовательских интерфейсов. Основывается на идее декларативного программирования(состоит в описании конечного результата).
</details>

<details>
  <summary>Что такое JSX?</summary>

JSX расшифровывается как Java Script XML.
Это просто расширение для JavaScript, которое позволяет писать код, подобный XML, для простоты и элегантности, а затем вы транспилируете JSX через babel или ts в чистые вызовы функций JavaScript с помощью React.createElement.

</details>

<details>
  <summary>Что такое props?</summary>

Сокращенно от Properties. Входящие свойства в компонент. Они только для чтения и
их нельзя менять. Всегда идут от родителя к ребенку.

</details>

<details>
  <summary>Что такое refs в React?</summary>

Сокращенно от References. Специальный атрибут, позволяющий получить доступ до
конкретного DOM элемента
Нужен для:

- Вызова анимаций
- Для задания фокуса или выделения текста
- Взаимодействия со сторонними библиотеками

</details>

<details>
  <summary>В чем разница между state и props?</summary>

state - структура данных, необходимая для изменения и отслеживания
пользовательских действий

props - набор конфигурации, поступающий от родительского элемента. Их нельзя
изменять

</details>

<details>
  <summary>В чем смысл специального атрибута key?</summary>

Атрибут позволяет React понимать, какие именно элементы в списке были
модифицированы или удалены, что увеличивает производительность рендеринга.

Лучше всего использовать уникальные значения, такие как ID. Индексы использовать
не рекомендуется

</details>

<details>
  <summary>Какие методы жизненного цикла компонента существуют в React?</summary>
  
- render() — единственный обязательный метод в классовом компоненте.
При вызове он проверяет this.props и this.state и возвращает один из следующих вариантов: Элемент React, Массивы и фрагменты, Порталы, Строки и числа, Booleans или null

- constructor() - Конструктор компонента React вызывается до того, как компонент будет примонтирован. В начале конструктора необходимо вызывать super(props). Если это не сделать, this.props не будет определён. Это может привести к багам.
  Конструкторы в React обычно используют для двух целей: Инициализация внутреннего состояния через присвоение объекта this.state. Привязка обработчиков событий к экземпляру.
  Конструктор — единственное место, где можно напрямую изменять this.state. В остальных методах необходимо использовать this.setState().

- componentDidMount() - вызывается сразу после монтирования (то есть, вставки компонента в DOM). В этом методе должны происходить действия, которые требуют наличия DOM-узлов. Это хорошее место для создания сетевых запросов.
  Этот метод подходит для настройки подписок. Но не забудьте отписаться от них в componentWillUnmount().

- componentDidUpdate(prevProps, prevState, snapshot) - вызывается сразу после обновления. Не вызывается при первом рендере. Метод позволяет работать с DOM при обновлении компонента. Также он подходит для выполнения таких сетевых запросов, которые выполняются на основании результата сравнения текущих пропсов с предыдущими. Если пропсы не изменились, новый запрос может и не требоваться.

- componentWillUnmount() - вызывается непосредственно перед размонтированием и удалением компонента. В этом методе выполняется необходимый сброс: отмена таймеров, сетевых запросов и подписок, созданных в componentDidMount().

- shouldComponentUpdate(nextProps, nextState) - вызывается перед рендером, когда получает новые пропсы или состояние. Значение по умолчанию равно true. Этот метод нужен только для повышения производительности.. Но не опирайтесь на его возможность «предотвратить» рендер, это может привести к багам. Вместо этого используйте PureComponent, который позволяет не описывать поведение shouldComponentUpdate() вручную. PureComponent поверхностно сравнивает пропсы и состояние и позволяет не пропустить необходимое обновление.

- static getDerivedStateFromProps(props, state) - вызывается непосредственно перед вызовом метода render, как при начальном монтировании, так и при последующих обновлениях. Он должен вернуть объект для обновления состояния или null, чтобы ничего не обновлять.
  Этот метод существует для редких случаев, когда состояние зависит от изменений в пропсах.

- getSnapshotBeforeUpdate(prevProps, prevState) - вызывается прямо перед этапом «фиксирования» (например, перед добавлением в DOM). Он позволяет вашему компоненту брать некоторую информацию из DOM (например, положение прокрутки) перед её возможным изменением. Любое значение, возвращаемое этим методом жизненного цикла, будет передано как параметр componentDidUpdate().

- static getDerivedStateFromError(error) - Этот метод жизненного цикла вызывается после возникновения ошибки у компонента-потомка. Он получает ошибку в качестве параметра и возвращает значение для обновления состояния. getDerivedStateFromError() вызывается во время этапа «рендера». Поэтому здесь запрещены любые побочные эффекты, но их можно использовать в componentDidCatch().

- componentDidCatch(error, info) - Этот метод жизненного цикла вызывается после возникновения ошибки у компонента-потомка. Он получает два параметра: error — перехваченная ошибка, info — объект с ключом componentStack, содержащий информацию о компоненте, в котором произошла ошибка. Метод можно использовать для логирования ошибок.

<img src='https://camo.githubusercontent.com/5de529ff1ae2c01cbb863f8f49123384959b23f317e4a76f7bd58be8b08b7434/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f313630302f312a6350777655685a726e423164745a6e6a4245665866412e706e67'>

</details>

<details>
  <summary>Что такое Virtual DOM (VDOM)</summary>

DOM расшифровывается как Document Object Model (объектная модель документа). Проще говоря, DOM — это представление пользовательского интерфейса (user interface, UI) в приложении. При каждом изменении UI, DOM также обновляется для отображения этих изменений. Частые манипуляции с DOM негативно влияют на производительность.

DOM представляет собой древовидную структуру данных. Поэтому изменения и обновления самого DOM являются достаточно быстрыми. Но после изменения обновленный элемент и все его потомки (дочерние элементы) должны быть повторно отрисованы (отрендерены) для обновления UI приложения. Повторный рендеринг — очень медленный процесс. Таким образом, чем больше у нас компонентов UI, тем более дорогими с точки зрения производительности являются обновления DOM.

Неэффективное обновление часто становится серьезной проблемой. Для решения данной проблемы команда React популяризовала нечто под названием виртуальный (virtual) DOM (VDOM).

В React для каждого объекта настоящего DOM (далее — RDOM) существует соответствующий объект VDOM. VDOM — это объектное представление RDOM, его легковесная копия. VDOM содержит те же свойства, что и RDOM, но не может напрямую влиять на то, что отображается на экране.

  <img src='https://habrastorage.org/r/w780/getpro/habr/post_images/a24/a2a/a11/a24a2aa1136f517abc80ae25c20f6c8a.png'>

  <p><i>Источник: <a href='https://habr.com/ru/company/macloud/blog/558682/'>habr.com</a></i></p>
</details>

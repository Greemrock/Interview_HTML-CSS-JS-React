<details>
  <summary>Что такое семантическая вёрстка и зачем она нужна?</summary>
  <br>
  <ul>
    <li>Чтобы сделать сайт доступным. Зрячие пользователи могут без проблем с первого взгляда понять, где какая часть
      страницы находится — где заголовок, списки или изображения. Для незрячих или плохо видящих основной инструмент для
      просмотра сайтов не браузер, который отрисовывает страницу, а скринридер, который читает текст со страницы вслух.
    </li>
    <li>Чтобы сайт был выше в поисковиках. Наличие семантической разметки страниц помогает поисковым ботам лучше
      понимать, что находится на странице, и в зависимости от этого ранжировать сайты в поисковой выдаче.</li>
    <li>Tags: article, section, aside, nav, header, main, footer, h1-h6, ul...</li>
</details>

<details>
  <summary>Что такое DNS(Domain Name System)?</summary>
  <br>
  <p>Это глобальное распределенное хранилище ключей и значений. Сервера по всему миру могут предоставить вам значение по
    ключу, а если им неизвестен ключ, то они попросят помощи у другого сервера.</p>
  <p>Вы или ваш браузер запрашивает значение для ключа www.example.com, и получает в ответ 1.2.3.4.</p>
  <p><i>Источник: <a href='https://habr.com/ru/post/303446/'>habr.com</a></i></p>
</details>

<details>
  <summary>Как работают браузеры(HTTP)?</summary>
  <br>
  <div>
    <span>Работа браузера в основном состоит из:
      <ul>
        <li>Разрешение DNS</li>
        <li>HTTP-обмен</li>
        <li>Рендеринг</li>
        <li>Сброс и повтор</li>
      </ul>
  </div>
  <h4>Разрешение DNS</h4>
  <p>Этот процесс помогает браузеру узнать, к какому серверу он должен подключиться, когда пользователь вводит URL.
    Браузер связывается с DNS-сервером и обнаруживает, что google.com соответствует набору цифр 216.58.207.110 —
    IP-адресу, к которому может подключиться браузер.
  <p>
  <h4>HTTP-обмен</h4>
  <p>Как только браузер определит, какой сервер будет обслуживать наш запрос, он установит с ним TCP-соединение и начнет
    HTTP-обмен.
  <p>
  <p>HTTP — это просто название самого популярного протокола для общения в сети, и браузеры в основном выбирают HTTP при
    общении с серверами. HTTP-обмен подразумевает, что клиент (наш браузер) отправляет запрос, а сервер присылает ответ.
  <p>
  <h4>Рендеринг</h4>
  <p>В теле ответа сервер включает представление запрашиваемого документа в соответствии с заголовком Content-Type. В
    нашем случае тип содержимого был установлен на text/html, поэтому мы ожидаем HTML-разметку в ответе — и именно ее мы
    и находим в теле документа.
  <p>
  <p>Это как раз тот момент, где браузер действительно проявляет свои способности. Он считывает и анализирует HTML-код,
    загружает дополнительные ресурсы, включенные в разметку (например, там могут быть указаны для подгрузки
    JavaScript-файлы или CSS-документы) и представляет их пользователю как можно скорее.</p>
  <p><i>Источник: <a href='https://habr.com/ru/company/edison/blog/432870/'>habr.com</a></i></p>
</details>

<details>
  <summary>Разница между LocalStorage, SessionStorage, Cookies</summary>
  <br>
  <span>Local Storage (локальное хранилище)</span>
  <ul>
    <li>Хранит данные бессрочно.</li>
    <li>Очищается только с помощью JavaScript или очистки кэша браузера.</li>
    <li>Хранит данные объёмом до 5 МБ, это самый большой объём из трёх вариантов хранилища.</li>
    <li>Не поддерживается старыми браузерами, например, IE 7 и ниже.</li>
    <li>Работает по правилу ограничения домена (same origin policy). То есть сохранённые данные доступны только для
      одного источника.</li>
  </ul>
  <br>
  <span>Session Storage (сессионное хранилище)</span>
  <ul>
    <li>Хранит данные, пока продолжается текущая сессия. Когда пользователь закрывает браузер, данные становятся
      недоступными.</li>
    <li>Используется контекст браузера верхнего уровня, поэтому каждая вкладка браузера хранит уникальные данные.</li>
    <li>Объём данных больше чем в Cookie.</li>
    <li>Не поддерживается старыми браузерами, например, IE 7 и ниже.</li>
  </ul>
  <br>
  <span>Cookie</span>
  <ul>
    <li>Хранит данные, которые можно передавать на сервер через заголовки.</li>
    <li>Локальное и сессионное хранилище доступны только на клиентской стороне.</li>
    <li>Срок хранения устанавливается при создании cookie.</li>
    <li>Объём данных не превышает 4 Кбайт.</li>
    <li>Cookie могут быть защищёнными, в этом случае их содержимое нельзя получить на стороне клиента. Это важно для
      аутентификации при хранении пользовательских токенов.</li>
  </ul>
  <p><i>Источник: <a
        href='https://ru.hexlet.io/blog/posts/lokalnoe-hranilische-vs-sessionnoe-hranilische-vs-cookie'>hexlet.io</a></i>
  </p>
</details>

<br>
<b>CSS</b>

<details>
  <summary>Что такое селекторы?</summary>
  <br>
  <p>Селектор определяет, к какому элементу применять то или иное CSS-правило.</p>
  <span>Основных видов селекторов всего несколько:</span>
  <ul>
    <li>* – любые элементы.</li>
    <li>div – элементы с таким тегом.</li>
    <li>#id – элемент с данным id.</li>
    <li>.class – элементы с таким классом.</li>
    <li>[name="value"] – селекторы на атрибут</li>
    <li>:visited – «псевдоклассы», остальные разные условия на элемент</li>
  </ul>
  <br>
  <p><i>Источник: <a href='https://learn.javascript.ru/css-selectors'>javascript.ru</a></i></p>
</details>

<details>
  <summary>Что такое спецефичность селекторов?</summary>
  <br>
  <p>Специфичность - это способ, с помощью которого браузеры определяют, какие значения свойств CSS наиболее
    соответствуют элементу и, следовательно, будут применены.</p>
  <span>Спецефичность селекторов:</span>
  <table>
    <tbody>
      <tr>
        <td>Селектор тега:</td>
        <td>1</td>
      </tr>
      <tr>
        <td>Селектор класса:</td>
        <td>10</td>
      </tr>
      <tr>
        <td>Селектор ID:</td>
        <td>100</td>
      </tr>
      <tr>
        <td>Inline-стиль:</td>
        <td>1000</td>
      </tr>
    </tbody>
  </table>
  <p><i>Источник: <a href='https://developer.mozilla.org/ru/docs/Web/CSS/Specificity'>developer.mozilla.org</a></i></p>
</details>

<details>
  <summary>Что такое вложенные селекторы?</summary>
  <br>
  <p>В HTML можно вписать одни теги в другие. В CSS мы можем выбирать те теги, которые вложены в какой-либо тег. Для
    этого используется конструкция вложенных селекторов (A B). Например, мы можем задать стили для всех em, которые
    находятся в тегах div.</p>
  <code>
    #example em {
      color: #cc4d4d;
    }
  </code>
  <p><i>Источник: <a href='https://developer.mozilla.org/ru/docs/Web/CSS/Specificity'>developer.mozilla.org</a></i></p>
</details>

<details>
  <summary>Position</summary>
  <ul>
    <li>
      <span>static</span>
      <p>static ещё называют не позиционированным(отпозиционированы статически, то есть никак).</p>>
    </li>
    <li>
      <span>relative</span>
      <p>Относительное позиционирование сдвигает элемент относительно его обычного положения.</p>>
    </li>
    <li>
      <span>absolute</span>
      <p>Абсолютное позиционирование делает две вещи: Элемент исчезает с того места, где он должен быть и позиционируется заново и Координаты top/bottom/left/right для нового местоположения отсчитываются от ближайшего позиционированного родителя.</p>>
    </li>
    <li>
      <span>fixed</span>
      <p>Позиционирует объект точно так же, как absolute, но относительно window.</p>>
      <p>Когда страницу прокручивают, фиксированный элемент остаётся на своём месте и не прокручивается вместе со страницей.</p>
    </li>
    <li>
      <span>sticky </span>
      <p>sticky может перемещаться только в пределах контейнера, в котором находится.</p>>
    </li>
  </ul>
</details>

<details>
  <summary>display</summary>
  <ul>
    <li>
      <span>none</span>
      <p>Элемент не показывается, вообще. Как будто его и нет.</p>
    </li>
    <li>
      <span>block</span>
      <p>Блочные элементы располагаются один над другим, вертикально (если нет особых свойств позиционирования, например float).</p>
      <p>Блок стремится расшириться на всю доступную ширину. Можно указать ширину и высоту явно.</p>
    </li>
    <li>
      <span>inline</span>
      <p>Блочные элементы располагаются один над другим, вертикально (если нет особых свойств позиционирования, например float).
      </p>
      <p>Блок стремится расшириться на всю доступную ширину. Можно указать ширину и высоту явно.</p>
    </li>
    <li>
      <span>inline-block</span>
      <p>Это значение – означает элемент, который продолжает находиться в строке (inline), но при этом может иметь важные свойства блока.</p>
    </li>
    <li>
      <span>table-*</span>
      <p>Современные браузеры (IE8+) позволяют описывать таблицу любыми элементами, если поставить им соответствующие значения display.</p>
    </li>
    <li>
      <span>flex</span>
    </li>
    <li>
      <span>grid</span>
    </li>
  </ul>
</details>

<br>
<b>JavaScript</b>

<details>
  <summary>Что такое Hoisting?</summary>
  <br>
  <p>Поднятие или hoisting — это механизм в JavaScript, в котором переменные и объявления функций, передвигаются вверх своей области видимости перед тем, как код будет выполнен.</p>
  <p>JavaScript сначала объявляет, а уже затем инициализирует наши переменные.</p>
  <ul>
    <li>
      <span>var</span>
      <p>Областью видимости переменной, объявленной через var, является её настоящий контекст выполнения.</p>
  <code>

    console.log(hoist); // Вывод: undefined
    var hoist = 'The variable has been hoisted.';
    function hoist() {
      console.log(message);
      message='Hoisting is all the rage!'
    }
    hoist(); // Вывод: undefined
  </code>
    </li>
    <li>
      <span>let</span>
      <p>Переменные объявленные через let заключены в область видимости блока, а не функции.</p>
      <p>Вкратце, это просто говорит о том, что область видимости переменной привязана к блоку, в котором она объявлена, а не к функции в которой она объявлена.</p>
  <code>

    console.log(hoist); // Вывод: ReferenceError: hoist is not defined 
    ...
    let hoist = 'The variable has been hoisted.';
  </code>
    </li>
    <li>
      <span>const</span>
      <p>Const была представлена в es6 для того, чтобы можно было сделать неизменные переменные.</p>
    </li>
    <p>Переменные объявленные с let и const остаются неинициализированными в начале выполнения, в то время как переменные объявленные с var инициализируются со значением undefined.</p>
    <br>
    <b>Поднятие функций</b>
    <span>Объявленные функции</span>
    <p>Такие функции полностью поднимаются вверх кода.</p>
  <code>

    hoisted(); // Вывод: "This function has been hoisted."
    function hoisted() {
      console.log('This function has been hoisted.');
    };
  </code>
        <p>Функциональные выражения, однако, не поднимаются.</p>
  <code>

    expression(); //Вывод: "TypeError: expression is not a function
    var expression = function() {
      console.log('Will this work?');
    };
  </code>
  <p><i>Источник: <a href='https://medium.com/@stasonmars/%D1%80%D0%B0%D0%B7%D0%B1%D0%B8%D1%80%D0%B0%D0%B5%D0%BC%D1%81%D1%8F-%D1%81-%D0%BF%D0%BE%D0%B4%D0%BD%D1%8F%D1%82%D0%B8%D0%B5%D0%BC-hoisting-%D0%B2-javascript-7d2d27bc51f1'>medium.com</a></i></p>
</details>

<details>
  <summary>Что такое замыкание?</summary>
  <br>
  <p>Замыкание это функция у которой есть доступ к своей внешней функции по области видимости, даже после того, как внешняя функция прекратилась. Это говорит о том, что замыкание может запоминать и получать доступ к переменным, и аргументам своей внешней функции, даже после того, как та прекратит выполнение.</p>
  <code>
    function getCounter() {
      let counter = 0;
      return function() {
        return counter++;
      }
    }
    let count = getCounter();
    console.log(count());  // 0
    console.log(count());  // 1
    console.log(count());  // 2
  </code>
  <p>Мы храним анонимную внутреннюю функцию, возвращенную функцией getCounter в переменной count. Так как функция сount теперь замыкание, она может получать доступ к переменной counter в функции getCounter, даже после того, как та завершится.</p>
  <p>Но обратите внимание, что значение counter не сбрасывается до 0 при каждом вызове count, как вроде бы она должна делать.
  </p>
  <p>Так происходит, потому что при каждом вызове count(), создаётся новая область видимости, но есть только одна область видимости, созданная для getCounter, так как переменная counter объявлена в области видимости getCounter(), она увеличится при каждом вызове функции count, вместо того, чтобы сброситься до 0.</p>
  <p><i>Источник: <a href='https://medium.com/@stasonmars/%D0%BF%D0%BE%D0%BD%D0%B8%D0%BC%D0%B0%D0%B5%D0%BC-%D0%B7%D0%B0%D0%BC%D1%8B%D0%BA%D0%B0%D0%BD%D0%B8%D1%8F-%D0%B2-javascript-%D1%80%D0%B0%D0%B7-%D0%B8-%D0%BD%D0%B0%D0%B2%D1%81%D0%B5%D0%B3%D0%B4%D0%B0-c211805b6898'>medium.com</a></i></p>
</details>

<details>
  <summary>Что такое контекст выполнения?</summary>
  <br>
  <p>Это абстрактная среда, в которой JavaScript код оценивается и выполняется. Когда выполняется “глобальный” код, он выполняется внутри глобального контекста выполнения, а код функции выполняется внутри контекста выполнения функции.</p>
  <img src="https://miro.medium.com/max/875/1*huMb5-_MmM8zkFVnchsjbg.png" alt="">
  <p>Во время выполнения этого кода, движок JavaScript создаёт глобальный контекст вызова, для того, чтобы выполнить глобальный код и когда он доходит до вызова функции first(), он создаёт новый контекст выполнения для этой функции и ставит её на вершину стека вызовов.</p>
  <p>Когда функция first() завершится, её стек выполнения удалится и начнется выполнение кода ниже. Так что оставшийся код в глобальной области видимости будет выполнен.</p>
  <p><i>Источник: <a href='https://medium.com/@stasonmars/%D0%BF%D0%BE%D0%BD%D0%B8%D0%BC%D0%B0%D0%B5%D0%BC-%D0%B7%D0%B0%D0%BC%D1%8B%D0%BA%D0%B0%D0%BD%D0%B8%D1%8F-%D0%B2-javascript-%D1%80%D0%B0%D0%B7-%D0%B8-%D0%BD%D0%B0%D0%B2%D1%81%D0%B5%D0%B3%D0%B4%D0%B0-c211805b6898'>medium.com</a></i></p>
</details>

<details>
  <summary>Что такое лексическое окружение?</summary>
  <br>
  <p>Каждый раз, когда движок JavaScript создаёт контекст выполнения, чтобы выполнить функцию или глобальный код, он также создаёт новое лексическое окружение, чтобы хранить переменную определенную в этой функции во время её выполнения.
  </p>
  <p>Лексическое окружение это структура данных, которая хранит информацию по идентификаторам переменных. Тут идентификатор обозначает имя переменных/функций, а переменная настоящий объект[включая тип функции] или примитивное значение.</p>
  <span>У лексического окружения есть два компонента: (1) запись в окружении и (2) отсылка к внешнему окружению.</span>
  <ul>
    <li>Запись в окружении(environment record) это место хранятся объявления переменной или функции.</li>
    <li>Отсылка к внешнему окружению (reference to the outer environment) означает то, что у него есть доступ к внешнему (родительскому) лексическому окружению. Этот компонент самый важный для понимания того, как работают замыкания.</li>
  </ul>
  <p><b>Обратите внимание</b> — когда функция выполняется, её контекст выполнения удаляется из стека, но её лексическое окружение может или не может быть удалено из памяти, в зависимости от того, ссылается ли на это лексическое окружение другое лексическое окружение.</p>
  <p><i>Источник: <a href='https://medium.com/@stasonmars/%D0%BF%D0%BE%D0%BD%D0%B8%D0%BC%D0%B0%D0%B5%D0%BC-%D0%B7%D0%B0%D0%BC%D1%8B%D0%BA%D0%B0%D0%BD%D0%B8%D1%8F-%D0%B2-javascript-%D1%80%D0%B0%D0%B7-%D0%B8-%D0%BD%D0%B0%D0%B2%D1%81%D0%B5%D0%B3%D0%B4%D0%B0-c211805b6898'>medium.com</a></i></p>
</details>

<details>
  <summary>Разница межды func expression и declaration?</summary>
  <div>1</div>
</details>

<details>
  <summary>Что такое this?</summary>
  
</details>

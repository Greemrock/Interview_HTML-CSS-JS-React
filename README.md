## Common questions

<details>
  <summary>GIT</summary>

1. Что такое Git и чем он отличается от SVN?

- Git - это распределенная система контроля версий
- В отличие от SVN (централизованная система), в Git каждый разработчик имеет локальную копию всего репозитория
- Git позволяет работать офлайн, так как все операции выполняются локально
- Ветвление в Git намного легче и быстрее, чем в SVN

2. Основные команды Git:

- git init - инициализация нового репозитория
- git clone - клонирование существующего репозитория
- git add - добавление файлов в индекс
- git commit - создание коммита
- git push - отправка изменений в удаленный репозиторий
- git pull - получение изменений из удаленного репозитория
- git branch - работа с ветками
- git checkout - переключение между ветками
- git merge - слияние веток

3. Что такое Git Flow?

- Это методология ветвления в Git
- Основные ветки:
  - master - основная ветка с релизами
  - develop - ветка разработки
  - feature/\_ - ветки для новых функций
  - hotfix/\_ - ветки для срочных исправлений
  - release/\* - ветки для подготовки релиза

4. Что такое конфликт в Git и как его разрешить?

- Конфликт возникает, когда Git не может автоматически объединить изменения
- Разрешение конфликта:
  1. Открыть конфликтующие файлы
  2. Выбрать нужные изменения
  3. Удалить маркеры конфликта
  4. Добавить файлы в индекс
  5. Создать коммит

5. Что такое rebase и чем он отличается от merge?

- merge создает новый коммит слияния
- rebase переносит коммиты одной ветки в начало другой
- rebase делает историю более линейной
- rebase не рекомендуется использовать для публичных веток

6. Что такое cherry-pick?

- Команда позволяет взять изменения из одного коммита и применить их к другой ветке
- Полезно когда нужно перенести конкретное изменение, а не всю ветку

7. Что такое stash?

- Временное сохранение незакоммиченных изменений
- Полезно когда нужно быстро переключиться на другую задачу
- Основные команды:
  - git stash save - сохранить изменения
  - git stash pop - применить последние сохраненные изменения
  - git stash list - показать список сохранений

8. Как отменить изменения в Git?

- git reset - отмена индексации
- git reset --hard - отмена всех локальных изменений
- git revert - создание нового коммита, отменяющего изменения
- git checkout -- file - отмена изменений в файле

9. Что такое .gitignore?

- Файл, указывающий, какие файлы Git должен игнорировать
- Часто игнорируются:
  - Временные файлы
  - Логи
  - Зависимости (node_modules)
  - Конфигурационные файлы

10. Что такое pull request (PR)?

- Запрос на включение изменений из одной ветки в другую
- Позволяет:
  - Проводить код-ревью
  - Обсуждать изменения
  - Запускать автоматические тесты
  - Контролировать качество кода

11. Что такое git bisect?

- Инструмент для поиска коммита, который внес ошибку
- Использует бинарный поиск
- Полезен при отладке

12. Как работать с тегами в Git?

- Теги используются для маркировки важных точек в истории (например, релизов)
- Основные команды:
  - git tag - просмотр тегов
  - git tag -a v1.0 -m "message" - создание аннотированного тега
  - git push --tags - отправка тегов в удаленный репозиторий

13. Что такое git hooks?

- Скрипты, которые Git запускает до или после определенных событий
- Примеры:
  - pre-commit
  - post-commit
  - pre-push
  - post-merge

14. Как обезопасить себя от случайной отправки чувствительных данных в репозиторий?

- Использовать .gitignore
- Использовать git-secrets или похожие инструменты
- Хранить чувствительные данные в переменных окружения
- Регулярно проверять историю коммитов

15. Что такое git blame?

- Команда показывает, кто и когда внес изменения в каждую строку файла
- Полезна для:
  - Поиска автора конкретного изменения
  - Понимания истории изменений
  - Отладки

</details>

<details>
  <summary>OOП</summary>
  
####  Основные принципы ООП:

1. Наследование - возможность создать новый класс на основе существующего. Например, можно создать класс SportsCar, который наследует все свойства и методы от Car, но добавляет что-то своё:
   Apply to README.md
2. Инкапсуляция - это как "черный ящик". Снаружи мы видим только то, что нам нужно видеть, а внутренние механизмы скрыты. Например, нам не нужно знать, как именно работает двигатель, чтобы завести машину.
3. Полиморфизм - способность объектов с одинаковым интерфейсом иметь различное поведение.

#### Преимущества ООП:

- Код становится более организованным и понятным
- Легче поддерживать и изменять программу
- Можно переиспользовать код (не нужно писать одно и то же несколько раз)
- Проще работать в команде, так как код разделен на логические блоки

ООП помогает структурировать код так, чтобы он был более понятным и удобным для работы, особенно в больших проектах. Это как конструктор LEGO - у вас есть разные детали (объекты), которые можно собирать вместе разными способами для создания более сложных структур.

#### В React наследование может быть реализовано несколькими способами:

1. Классовые компоненты с наследованием.
2. Современный подход с композицией (предпочтительный). Вместо наследования в React чаще используется композиция компонентов.
3. Паттерн Higher-Order Components (HOC)
4. Использование хуков

</details>
<details>
  <summary>Объяснить простыми словами что происходит когда ты переходишь на страницу в браузере?
</summary>
<br/>

---

### 1. **Ввод адреса**

Ты вводишь URL (например, `https://example.com`) в адресную строку браузера и нажимаешь Enter.

---

### 2. **DNS-запрос**

Браузер отправляет запрос к **DNS-серверу** (система доменных имен), чтобы узнать, какой IP-адрес соответствует введенному домену (например, `example.com`). Это как поиск адреса дома по его названию.

- Если DNS-сервер уже знает IP-адрес (например, он был сохранен в кеше), он сразу возвращает его.
- Если нет, DNS-сервер выполняет поиск по цепочке, пока не найдет нужный IP.

---

### 3. **Установка соединения**

Браузер использует полученный IP-адрес, чтобы установить соединение с сервером. Это происходит через протокол **TCP/IP** (Transmission Control Protocol/Internet Protocol).

- Если сайт использует HTTPS (а большинство современных сайтов используют), браузер также устанавливает безопасное соединение через **SSL/TLS**. Это как "рукопожатие" между браузером и сервером, чтобы убедиться, что данные передаются безопасно.

---

### 4. **Запрос страницы**

Браузер отправляет **HTTP-запрос** на сервер. Этот запрос содержит информацию о том, какую страницу ты хочешь получить (например, главную страницу или конкретный раздел сайта).

- Запрос может быть типа `GET` (получить данные) или `POST` (отправить данные, например, форму).
- Запрос также включает заголовки, такие как тип браузера, язык, cookies и т.д.

---

### 5. **Обработка запроса сервером**

Сервер получает запрос и обрабатывает его. В зависимости от запроса, сервер может:

- Просто отдать статический файл (например, HTML, CSS, изображение).
- Выполнить код на сервере (например, PHP, Python, Node.js), чтобы сгенерировать динамический контент (например, данные из базы данных).
- Отправить ответ обратно браузеру. Ответ включает:
  - **HTTP-статус** (например, `200 OK` — успешно, `404 Not Found` — страница не найдена).
  - **HTML-код** страницы.
  - Дополнительные ресурсы, такие как CSS, JavaScript, изображения и т.д.

---

### 6. **Получение данных**

Браузер получает ответ от сервера и начинает загружать HTML-код страницы. Если в HTML есть ссылки на другие ресурсы (например, CSS, JavaScript, изображения), браузер отправляет дополнительные запросы, чтобы загрузить их.

---

### 7. **Парсинг и отображение**

Теперь браузер начинает "собирать" страницу:

1. Получение HTML
   Когда пользователь вводит адрес сайта и нажимает Enter, браузер отправляет HTTP-запрос к серверу и получает HTML-документ.
2. Парсинг HTML
   - HTML Parser начинает читать HTML-код построчно.
   - На основе тегов строится DOM-дерево (Document Object Model) — иерархическая структура, отражающая вложенность элементов на странице.
3. Загрузка и парсинг CSS
   - Когда парсер встречает теги link или style, начинается загрузка и парсинг CSS-файлов.
   - На основе CSS строится CSSOM (CSS Object Model) — структура, описывающая стили для каждого элемента.
4. Построение Render Tree
   - Render Tree (дерево рендеринга) строится на основе DOM и CSSOM.
   - В Render Tree включаются только видимые элементы (например, элементы с display: none не попадают).
   - Каждый узел содержит информацию о том, как и где должен отображаться элемент.
5. Layout (Вычисление геометрии, reflow)
   - Для каждого элемента Render Tree вычисляются точные размеры и положение на странице (ширина, высота, координаты).
   - Этот этап называется layout или reflow.
6. Painting (Отрисовка)
   - Браузер "рисует" (paint) пиксели на экране согласно Render Tree и рассчитанным стилям.
   - Сначала рисуются фоны, затем текст, затем границы и т.д.
7. Composite (Композиция)
   - Если используются слои (например, для анимаций, видео, 3D-трансформаций), браузер собирает их вместе на финальном этапе.
   - Это позволяет ускорить анимации и переходы.
8. Rasterization (Растеризация)
   - Каждый слой или всё изображение преобразуется из векторных данных (DOM, CSS, SVG и т.д.) в пиксели.
   - Этот процесс выполняется на уровне графического движка браузера, часто с помощью GPU (графического процессора).
   - В результате получается "картинка", которую можно вывести на экран.
9. Display (Отображение)
   - Финальный этап: полученное растеризованное изображение отправляется на экран пользователя.
   - Пользователь видит обновлённую страницу.

Важные моменты

- JavaScript может изменять DOM и CSSOM (например, через document.createElement или element.style), что может вызывать повторный layout и repaint.
- Блокирующие ресурсы:
  - CSS блокирует рендеринг, пока не будет загружен и обработан.
  - JavaScript (если не async/defer) блокирует парсинг HTML.
- Оптимизация:
  - Минимизируйте количество reflow/repaint для повышения производительности.
  - Используйте async/defer для скриптов, чтобы не блокировать парсинг.

### Кратко

1. HTML → Парсинг → DOM
2. CSS → Парсинг → CSSOM
3. DOM + CSSOM → Render Tree
4. Render Tree → Layout (размеры/позиции)
5. Layout → Paint (отрисовка)
6. Paint → Composite (слои, финальная сборка)
7. Composite → Rasterization (преобразование в пиксели)
8. Rasterization → Display (вывод на экран)
9. Пользователь видит страницу

---

### 8. **Отображение страницы**

Когда все ресурсы загружены и обработаны, браузер отображает страницу на экране. Теперь ты видишь содержимое сайта и можешь с ним взаимодействовать.

---

### 9. **Дополнительные запросы**

Если на странице есть динамические элементы (например, видео, картинки, которые подгружаются позже, или данные, загружаемые через AJAX), браузер может отправлять дополнительные запросы на сервер. Это происходит без перезагрузки страницы, благодаря технологиям, таким как **AJAX** (Asynchronous JavaScript and XML) или **Fetch API**.

- Например, когда ты прокручиваешь страницу, и подгружаются новые посты, это работает через дополнительные запросы.

---

### Итог

Вот что происходит, когда ты переходишь на страницу:

1. Вводишь адрес.
2. Браузер ищет IP-адрес через DNS.
3. Устанавливает соединение с сервером.
4. Отправляет запрос на сервер.
5. Сервер обрабатывает запрос и отправляет ответ.
6. Браузер загружает HTML, CSS, JavaScript и другие ресурсы.
7. Браузер парсит HTML, CSS, строит DOM, CSSOM, Render Tree, выполняет Layout, Paint и Composite.
8. Страница отображается на экране.
9. Если нужно, браузер отправляет дополнительные запросы для подгрузки данных.

</details>

<details>
  <summary>Что такое DNS(Domain Name System)?</summary>
  <br>
  <p>Это глобальное распределенное хранилище ключей и значений. Сервера по всему миру могут предоставить вам значение по
    ключу, а если им неизвестен ключ, то они попросят помощи у другого сервера.</p>
  <p>Вы или ваш браузер запрашивает значение для ключа www.example.com, и получает в ответ 1.2.3.4.</p>
  <p><i>Источник: <a href='https://habr.com/ru/post/303446/'>habr.com</a></i></p>
</details>

<details>
  <summary>Как работают браузеры(HTTP)?</summary>

Работа браузера в основном состоит из:

- Разрешение DNS
- HTTP-обмен
- Рендеринг
- Сброс и повтор

### Разрешение DNS

Этот процесс помогает браузеру узнать, к какому серверу он должен подключиться, когда пользователь вводит URL.
Браузер связывается с DNS-сервером и обнаруживает, что google.com соответствует набору цифр 216.58.207.110 —
IP-адресу, к которому может подключиться браузер.

### HTTP-обмен

Как только браузер определит, какой сервер будет обслуживать наш запрос, он установит с ним TCP-соединение и начнет
HTTP-обмен.
HTTP — это просто название самого популярного протокола для общения в сети, и браузеры в основном выбирают HTTP при общении с серверами. HTTP-обмен подразумевает, что клиент (наш браузер) отправляет запрос, а сервер присылает ответ.

### Рендеринг

В теле ответа сервер включает представление запрашиваемого документа в соответствии с заголовком Content-Type. В нашем случае тип содержимого был установлен на text/html, поэтому мы ожидаем HTML-разметку в ответе — и именно ее мы и находим в теле документа.
Это как раз тот момент, где браузер действительно проявляет свои способности. Он считывает и анализирует HTML-код, загружает дополнительные ресурсы, включенные в разметку (например, там могут быть указаны для подгрузки JavaScript-файлы или CSS-документы) и представляет их пользователю как можно скорее.

Источник: [habr.com](https://habr.com/ru/company/edison/blog/432870/)

</details>

<details>
  <summary>Разница между LocalStorage, SessionStorage, Cookies</summary>
  <br>
  <span>Local Storage (локальное хранилище)</span>
  <ul>
    <li>Хранит данные бессрочно.</li>
    <li>Очищается только с помощью JavaScript или очистки кэша браузера.</li>
    <li>Хранит данные объёмом до 5 МБ, это самый большой объём из трёх вариантов хранилища.</li>
    <li>Не поддерживается старыми браузерами, например, IE 7 и ниже.</li>
    <li>Работает по правилу ограничения домена (same origin policy). То есть сохранённые данные доступны только для
      одного источника.</li>
  </ul>
  <br>
  <span>Session Storage (сессионное хранилище)</span>
  <ul>
    <li>Хранит данные, пока продолжается текущая сессия. Когда пользователь закрывает браузер, данные становятся
      недоступными.</li>
    <li>Используется контекст браузера верхнего уровня, поэтому каждая вкладка браузера хранит уникальные данные.</li>
    <li>Объём данных больше чем в Cookie.</li>
    <li>Не поддерживается старыми браузерами, например, IE 7 и ниже.</li>
  </ul>
  <br>
  <span>Cookie</span>
  <ul>
    <li>Хранит данные, которые можно передавать на сервер через заголовки.</li>
    <li>Локальное и сессионное хранилище доступны только на клиентской стороне.</li>
    <li>Срок хранения устанавливается при создании cookie.</li>
    <li>Объём данных не превышает 4 Кбайт.</li>
    <li>Cookie могут быть защищёнными, в этом случае их содержимое нельзя получить на стороне клиента. Это важно для
      аутентификации при хранении пользовательских токенов.</li>
  </ul>
  <p><i>Источник: <a
        href='https://ru.hexlet.io/blog/posts/lokalnoe-hranilische-vs-sessionnoe-hranilische-vs-cookie'>hexlet.io</a></i>
  </p>
</details>

<details>
  <summary>Что такое Big O?</summary>

Big O нотация нужна для описания сложности алгоритмов. Для этого используется понятие времени.

- O(1)

```javascript
const nums = [1, 2, 3, 4, 5];
const firstNumber = nums[0];
```

O(1) можно прочитать как «сложность порядка 1» (order 1), или «алгоритм выполняется за постоянное/константное время» (constant time).

- O(n)

```javascript
const nums = [1, 2, 3, 4, 5];
let sum = 0;
for (let num of nums) {
  sum += num;
}
```

Используя Big O нотацию: O(n), или «сложность порядка n (order n)». Так же такой тип алгоритмов называют «линейными» или что алгоритм «линейно масштабируется».

- O(n^2)

```javascript
const hasDuplicates = function (num) {
  //loop the list, our O(n) op
  for (let i = 0; i < nums.length; i++) {
    const thisNum = nums[i];
    //loop the list again, the O(n^2) op
    for (let j = 0; j < nums.length; j++) {
      //make sure we're not checking same number
      if (j !== i) {
        const otherNum = nums[j];
        //if there's an equal value, return
        if (otherNum === thisNum) return true;
      }
    }
  }
  //if we're here, no dups
  return false;
};
const nums = [1, 2, 3, 4, 5, 5];
hasDuplicates(nums); //true
```

Мы уже знаем что итерирование массива это O(n). У нас есть вложенный цикл, для каждого элемента мы еще раз итерируем — т.е. O(n^2) или «сложность порядка n квадрат».

Мышление в терминах Big O:

- Получение элемента коллекции это O(1). Будь то получение по индексу в массиве, или по ключу в словаре в нотации Big O это будет O(1)
- Перебор коллекции это O(n)
- Вложенные циклы по той же коллекции это O(n^2)
- Разделяй и властвуй (Divide and Conquer) всегда O(log n)
- Итерации которые используют Divide and Conquer это O(n log n)
</details>

<details>
  <summary>Какие структуры данных существуют?</summary>

Простыми словами, структура данных – это контейнер, который хранит информацию в определенном виде.

## Стек (вызовов) (Stack)

Стек следует принципу LIFO (Last In First Out — последним вошел, первым вышел).

## Очередь (кью) (Queue)

Очередь напоминает стек. Разница состоит в том, что очередь следует принципу FIFO (First In First Out — первым вошел, первым вышел). Когда вы стоите в очереди, первый в ней всегда будет первым.

    Порядок очередности (приоритет).
    Очередь имеет продвинутую версию. Присвойте каждому элементу приоритет, и элементы будут отсортированы соответствующим образом.

## Связный список (связанный, список узлов и ссылок или указателей) (Linked List)

Буквально, связный список — это цепочечная структура данных, где каждый узел состоит из двух частей: данных узла и указателя на следующий узел. Связный список и условный массив являются линейными структурами данных с сериализованным хранилищем. Отличия состоят в следующем:

<table>
  <tbody>
    <tr>
      <th>Критерий</th>
      <th>Массив</th>
      <th>Список</th>
    </tr>
    <tr>
      <td>Выделение памяти</td>
      <td>Статическое, происходит последовательно во время компиляции </td>
      <td>Динамическое, происходит асинхронно во время запуска (выполнения)</td>
    </tr>
    <tr>
      <td>Получение элементов</td>
      <td>Поиск по индексу, высокая скорость</td>
      <td>Поиск по всем узлам очереди, скорость менее высокая</td>
    </tr>
    <tr>
      <td>Добавление/удаление элементов</td>
      <td>В связи с последовательным и статическим распределением памяти скорость ниже</td>
      <td>В связи с динамическим распределением памяти скорость выше</td>
    </tr>
    <tr>
      <td>Структура</td>
      <td>Одно или несколько направлений</td>
      <td>Однонаправленный, двунаправленный или циклический</td>
    </tr>
  </tbody>
</table>

## Коллекция (значений) (Set)

Коллекция (множество) — одна из основных концепций математики: набор хорошо определенных и обособленных объектов. ES6 представил коллекцию, которая имеет некоторое сходство с массивом. Тем не менее, коллекция не допускает включения повторяющихся элементов и не содержит индексов.

## Хеш-таблица (таблица кэширования) (Hash Table)

Хеш-таблица — это структура данных, которая строится по принципу ключ-значение. Из-за высокой скорости поиска значений по ключам, она используется в таких структурах, как Map, Dictionary и Object. Как показано на рисунке, хеш-таблица имеет hash function, преобразующую ключи в список номеров, которые используются как имена (значения) ключей. Время поиска значения по ключу может достигать O(1). Одинаковые ключи должны возвращать одинаковые значения — в этом суть функции хэширования.

## Дерево (Tree)

Древовидная структура — это многослойная (многоуровневая) структура. Это также нелинейная структура, в отличие от массива, стека и очереди. Данная структура очень эффективна в части добавления и поиска элементов.

## Граф (график) (Graph)

Граф, также известный как сеть (Network), представляет собой коллекцию связанных между собой узлов. Бывает два вида графов — ориентированный и неориентированный, в зависимости от того, имеют ли ссылки направление. Графы используются повсеместно, например, для расчета наилучшего маршрута в навигационных приложениях или для формирования списка рекомендаций в социальных сетях.
Графы могут быть представлены в виде списка или матрицы.

</details>

<details>
  <summary>Какие типы данных существуют?</summary>

Стандарт ECMAScript определяет 8 типов:

- 6 типов данных являющихся примитивами:
  - Undefined (Неопределённый тип) : typeof instance === "undefined"
  - Boolean (Булев, Логический тип) : typeof instance === "boolean"
  - Number (Число) : typeof instance === "number"
  - String (Строка) : typeof instance === "string"
  - BigInt : typeof instance === "bigint"
  - Symbol (в ECMAScript 6) : typeof instance === "symbol"
- Null (Null тип ) : typeof instance === "object". Специальный примитив, используемый не только для данных но и в качестве указателя на финальную точку в Цепочке Прототипов;
- Object (Объект) : typeof instance === "object". Простая структура, используемая не только для хранения данных, но и для создания других структур, где любая структура создаётся с использованием ключевого слова new: new Object, new Array, new Map (en-US), new Set, new WeakMap, new WeakSet, new Date и множество других структур;

И здесь нам необходимо сделать предостережение относительно использования оператора typeof для определения типа структур, т.к. все структуры будут возвращать "object" при его использовании, так как назначение typeof -- проверка типа данных, но не структур. Если проверить тип структуры всё же необходимо, то в этом случае желательно использовать оператор instanceof, так как именно он отвечает на вопрос о том, какой конструктор был использован для создания структуры.

Источник: [developer.mozilla.org](https://developer.mozilla.org/ru/docs/Web/JavaScript/Data_structures)

</details>

<details>
  <summary>Патерны</summary>

Патерны проектирования — проверенный способ для решения проблем.

Порождающие шаблоны (Creational): создание новых объектов.

- Фабрика (Factory)
- Синглтон(Singletion)

Структурные шаблоны(Structural): упорядочивают объекты.

- Model-View-Сontroller (MVC)
- Model-View-ViewModel (MVVM):
  MVVM has four main blocks:
  - The View — UI слой где пользователи взаимодействуют с ним,
  - The ViewController — имеет доступ к ViewModel и обрабатывает ввод пользователя,
  - The ViewModel — имеет доступ к модели и обрабатывает бизнес-логику,
  - The Model — источник данных приложения
- Декоратор(Decorator): расширяет функциональность
- Фасад (Façade): используйте для создания простого интерфейса (абстрагирует функциональность, как например jQuery).

Поведенческие (Behavioral): позволяет объектам наблюдать за объектами и быть оповещенными об изменениях.

- Наблюдатель(Observer)
- Посредник(Mediator): один объект контролирует сообщение между объектами, поэтому объекты не сообщаются друг с другом на прямую.
- Команда(Command): инкапсулирует вызов метода в один объект.
</details>

<details>
  <summary>REST API</summary>
  
  REST API позволяет использовать для общения между программами протокол HTTP (зашифрованная версия — HTTPS), с помощью которого мы получаем и отправляем большую часть информации в интернете.

В API-системе четыре классических метода:

1. GET — метод чтения информации. GET-запросы всегда только возвращают данные с сервера, и никогда их не меняют и не удаляют. В бухгалтерском приложении GET /invoices вы открываете список всех счетов.
2. POST — создание новых записей. В нашем приложении POST /invoices используется, когда вы создаете новый счет на оплату.
3. PUT — редактирование записей. Например, PUT /invoices вы исправляете номер счета, сумму или корректируете реквизиты.
4. DELETE — удаление записей. В нашем приложении DELETE /invoices удаляет старые счета, которые контрагенты уже оплатили.
</details>

  <details>
  <summary>Flux архитектура</summary>

**Flux** — это архитектурный паттерн для управления данными в приложениях на JavaScript, особенно часто используется с React. Он помогает сделать код более предсказуемым и простым для поддержки.

### Зачем нужен Flux?

В больших приложениях сложно отслеживать, как и где изменяются данные. Flux решает эту проблему с помощью однонаправленного потока данных: данные всегда движутся в одном направлении, что упрощает отладку и понимание кода.

### Основные элементы Flux:

- **Action (Действие):** простое описание того, что произошло (например, пользователь нажал кнопку).
- **Dispatcher (Диспетчер):** получает action и передаёт его дальше.
- **Store (Хранилище):** хранит состояние приложения и реагирует на действия.
- **View (Представление):** отображает данные из Store (например, React-компонент).

### Как работает Flux (простая схема):

1. Пользователь взаимодействует с интерфейсом (View).
2. View вызывает Action (например, "добавить товар в корзину").
3. Action отправляется в Dispatcher.
4. Dispatcher передаёт Action в Store.
5. Store обновляет данные и сообщает View об изменениях.
6. View обновляется.

```
Пользователь → Action → Dispatcher → Store → View
```

### Пример на псевдокоде:

```js
// Action
const action = { type: 'ADD_ITEM', payload: { name: 'Товар' } };

// Dispatcher просто вызывает Store
store.handleAction(action);

// Store обновляет данные
handleAction(action) {
  if (action.type === 'ADD_ITEM') {
    this.items.push(action.payload);
    this.emitChange(); // Сообщаем View
  }
}
```

### Почему это важно для React?

Flux помогает сделать данные в React-приложениях более управляемыми и предсказуемыми. На основе Flux построены такие популярные библиотеки, как Redux.

**Подробнее:** [Официальная документация Flux (англ.)](https://facebook.github.io/flux/docs/overview/)

</details>

<br>

## Тестирование

<details>
  <summary>Типы тестирования</summary>

1. Модульное тестирование (Unit Testing)
   - Что это: Тестирование отдельных функций, компонентов или модулей приложения изолированно от остальной системы.
   - Зачем: Проверить, что каждая часть работает корректно сама по себе.
   - Инструменты: Jest, Mocha, Jasmine.
2. Интеграционное тестирование (Integration Testing)
   - Что это: Тестирование взаимодействия между несколькими модулями или компонентами.
   - Зачем: Убедиться, что части приложения правильно работают вместе (например, компонент + API).
   - Инструменты: Jest, React Testing Library, Enzyme.
3. Сквозное тестирование (End-to-End, E2E Testing)
   - Что это: Тестирование всего приложения целиком, как это делает реальный пользователь (от открытия страницы до выполнения действий).
   - Зачем: Проверить, что приложение работает как ожидается в реальных условиях.
   - Инструменты: Cypress, Selenium, Playwright.
4. Визуальное тестирование (Visual Regression Testing)
   - Что это: Проверка, что внешний вид компонентов/страниц не изменился неожиданно.
   - Зачем: Найти случайные изменения в верстке или стилях.
   - Инструменты: Storybook + Chromatic, Percy, Loki.
5. Тестирование пользовательского интерфейса (UI Testing)
   - Что это: Проверка, что элементы интерфейса отображаются и работают правильно (кнопки, формы и т.д.).
   - Зачем: Убедиться, что пользователь может взаимодействовать с приложением.
   - Инструменты: React Testing Library, Cypress.
6. Тестирование производительности (Performance Testing)
   - Что это: Оценка скорости загрузки, отклика и плавности работы интерфейса.
   - Зачем: Убедиться, что приложение быстро работает для пользователя.
   - Инструменты: Lighthouse, WebPageTest.
7. Тестирование доступности (Accessibility Testing, a11y)
   - Что это: Проверка, что приложение доступно для людей с ограниченными возможностями.
   - Зачем: Соответствие стандартам доступности (WCAG).
   - Инструменты: axe, Lighthouse, Wave.

Краткий ответ:
На фронтенде используют модульные, интеграционные, e2e, визуальные, UI, производительные и тесты доступности. Каждый тип теста проверяет разные аспекты приложения: от работы отдельных функций до взаимодействия пользователя с интерфейсом.

</details>

<details>
  <summary>Performance Testing</summary>

Performance Testing — это проверка, насколько быстро и плавно работает ваше веб-приложение для пользователя. Цель — убедиться, что сайт быстро загружается, быстро реагирует на действия пользователя и не «тормозит» даже при большом количестве данных или сложных анимациях.
Что обычно измеряют?

1. Время загрузки страницы (Page Load Time)
   - Сколько времени проходит от открытия сайта до полной загрузки и отображения контента.
2. Время до первого отображения (First Contentful Paint, FCP)
   - Когда пользователь впервые видит что-то на экране (например, текст или картинку).
3. Время до полной интерактивности (Time to Interactive, TTI)
   - Когда страница становится полностью готовой к взаимодействию (можно кликать, вводить текст и т.д.).
4. Время отклика на действия пользователя
   - Как быстро реагируют кнопки, формы, анимации.
5. Плавность анимаций и скролла
   - Нет ли «фризов» и лагов при прокрутке или анимациях.
6. Объем загружаемых данных
   - Размер HTML, CSS, JS, изображений и других ресурсов.

- Для ручного анализа — Lighthouse, WebPageTest, PageSpeed Insights, Chrome DevTools.
- Для автоматизации — Lighthouse CI, Puppeteer, Sitespeed.io.
- Для быстрой проверки — Web Vitals Extension.

</details>

<br>

## Безопасность

<details>
  <summary>Уязвимости frontend и способы их исключения</summary>

#### 1. XSS (Cross-Site Scripting) — Межсайтовый скриптинг

Что это:

Злоумышленник внедряет вредоносный JavaScript-код на страницу, который выполняется у других пользователей.

Как избежать:

- Никогда не вставляй пользовательские данные напрямую в DOM через innerHTML, document.write, и т.п.
- Используй безопасные методы вставки данных: textContent, innerText.
- Экранируй (sanitize) все пользовательские данные, которые отображаются на странице.
- Используй библиотеки для экранирования (например, DOMPurify).

#### 2. CSRF (Cross-Site Request Forgery) — Межсайтовая подделка запроса

Что это:
Злоумышленник заставляет пользователя выполнить нежелательное действие на сайте, где тот авторизован.

Как избежать:

- Используй CSRF-токены для всех форм и запросов, изменяющих данные.
- Для API — проверяй заголовки Origin/Referer.
- Не полагайся только на cookies для аутентификации.

#### 3. Clickjacking

Что это:

Злоумышленник внедряет сайт в iframe и заставляет пользователя кликать по невидимым элементам.

Как избежать:

- Устанавливай заголовок X-Frame-Options: DENY или SAMEORIGIN на сервере.
- Используй Content Security Policy (CSP): frame-ancestors 'none'.

#### 4. Утечка данных через исходный код

Что это:

Секреты, ключи API, пароли случайно попадают в frontend-код.

Как избежать:

- Никогда не храни секреты в frontend-коде.
- Используй переменные окружения только на сервере.
- Для доступа к приватным данным — только через backend.

#### 5. Man-in-the-Middle (MitM) — Перехват трафика

Что это:

Злоумышленник перехватывает и изменяет трафик между клиентом и сервером.

Как избежать:

- Используй HTTPS для всех соединений.
- Проверяй сертификаты.

#### 6. Инъекции через параметры URL или localStorage

Что это:

Пользователь может изменить параметры в URL или localStorage и вызвать нежелательное поведение.

Как избежать:

- Валидируй и проверяй все входные данные.
- Не доверяй данным из localStorage/sessionStorage/URL.

#### 7. CORS (Cross-Origin Resource Sharing)

Что это:

Неправильная настройка CORS может позволить злоумышленнику обращаться к вашему API с чужого сайта.

Как избежать:

- Настраивай CORS только для доверенных доменов.
- Не используй Access-Control-Allow-Origin: \* для приватных API.

#### 8. Content Security Policy (CSP)

Что это:
Отсутствие CSP позволяет внедрять вредоносные скрипты.

Как избежать:

- Настраивай CSP, чтобы разрешать выполнение только доверенных скриптов.

#### Кратко: как защищаться

- Не доверяй никаким входным данным.
- Экранируй и валидируй все данные.
- Используй HTTPS.
- Не храни секреты на клиенте.
- Настраивай заголовки безопасности (CSP, X-Frame-Options и др.).
- Используй современные фреймворки (React, Vue, Angular), которые по умолчанию защищают от XSS.

</details>

<br>

## Серверный рендеринг

<details>
  <summary>Виды серверного рендеринга</summary>

#### 1. Классический SSR (Server-Side Rendering)

- HTML-страница полностью формируется на сервере и отправляется клиенту.
- Пример: традиционные сайты на PHP, Ruby on Rails, а также React/Next.js с SSR.
- Преимущества: Быстрый первый рендер, SEO-дружелюбность.
- Недостатки: Серверная нагрузка, возможная задержка при интерактивности.

#### 2. SSG (Static Site Generation)

- Страницы генерируются на сервере заранее (на этапе сборки), а затем отдаются как статические файлы.
- Пример: Next.js (getStaticProps), Gatsby.
- Преимущества: Молниеносная отдача страниц, минимальная нагрузка на сервер.
- Недостатки: Не подходит для часто меняющихся данных.

#### 3. ISR (Incremental Static Regeneration)

- Гибрид SSG и SSR: страницы генерируются статически, но могут обновляться на сервере по расписанию или по запросу.
- Пример: Next.js (revalidate).
- Преимущества: Быстрота SSG + возможность обновления данных.
- Недостатки: Сложнее в реализации, возможны устаревшие данные.

#### 4. Streaming SSR (Потоковый SSR)

- Сервер отправляет HTML частями (потоком), позволяя браузеру начать отображение до завершения генерации всей страницы.
- Пример: React 18 (renderToPipeableStream).
- Преимущества: Быстрее отображается первый контент, улучшает UX.
- Недостатки: Требует поддержки на сервере и клиенте.

#### 5. CSR (Client-Side Rendering) — для сравнения

- Весь рендеринг происходит на клиенте, сервер отдаёт только "пустой" HTML и JS.
- Пример: Create React App, SPA.
- Преимущества: Меньше нагрузки на сервер, богатая интерактивность.
- Недостатки: Медленный первый рендер, проблемы с SEO.

</details>

<details>
  <summary>Какие есть плюсы и минусы SSR?</summary>

Плюсы:

- Быстрый первый рендер
- Хорошая индексация поисковиками (SEO)
- Контент доступен даже при медленном интернете

Минусы:

- Больше нагрузка на сервер
- Сложнее реализовать интерактивность
- Дольше время отклика при большом количестве пользователей

</details>

<details>
  <summary>Чем отличается SSR от SSG (Static Site Generation)?</summary>

SSR генерирует страницу на сервере при каждом запросе, а SSG — заранее, обычно при сборке проекта. SSG быстрее для пользователя, но не подходит для часто меняющихся данных.

</details>

<details>
  <summary>Какие проблемы могут возникнуть при SSR?</summary>

- Гидратация: синхронизация состояния между сервером и клиентом
- Работа с браузерными API (window, document) — их нет на сервере
- Долгое время отклика при сложных вычислениях на сервере

</details>

<details>
  <summary>Как работает HTTP-кеширование?</summary>

Сервер отправляет специальные заголовки (Cache-Control, Expires, ETag, Last-Modified), которые говорят браузеру, как долго хранить ресурс и когда его обновлять.

#### Основные механизмы HTTP-кеширования

1. Заголовки Cache-Control
   Это основной способ управления кешированием. Примеры значений:
   - Cache-Control: no-cache — всегда проверять актуальность у сервера.
   - Cache-Control: no-store — не сохранять в кеш вообще.
   - Cache-Control: public, max-age=3600 — можно кешировать всеми, срок жизни 1 час.
   - Cache-Control: private, max-age=600 — кешировать только в браузере пользователя, 10 минут.
2. Expires
   - Указывает дату и время, до которых ресурс считается свежим.
   - Пример: Expires: Wed, 21 Oct 2025 07:28:00 GMT
   - Устаревший способ, сейчас чаще используют Cache-Control.
3. ETag (Entity Tag)
   - Уникальный идентификатор версии ресурса (например, хеш содержимого).
   - При повторном запросе браузер отправляет If-None-Match: <etag>.
   - Если ресурс не изменился, сервер отвечает 304 Not Modified (ресурс не пересылается заново).
4. Last-Modified
   - Дата последнего изменения ресурса.
   - Браузер отправляет If-Modified-Since: <date>.
   - Если ресурс не менялся, сервер отвечает 304 Not Modified.
5. Vary
   - Управляет кешированием для разных версий ресурса (например, для разных языков или user-agent).
   - Пример: Vary: Accept-Encoding (разные версии для gzip и обычного контента).

#### Как работает процесс кеширования

1. Первый запрос:
   - Браузер запрашивает ресурс у сервера.
   - Сервер отправляет ресурс с заголовками кеширования.
   - Браузер сохраняет ресурс и информацию о правилах кеширования.
2. Повторный запрос:
   - Если ресурс ещё "свежий" (не истёк max-age/Expires), браузер берёт его из кеша, не обращаясь к серверу.
   - Если ресурс "протух" (истёк срок), браузер отправляет условный запрос с ETag или Last-Modified.
   - Если ресурс не изменился — сервер отвечает 304, браузер использует кеш.
   - Если изменился — сервер отправляет новый ресурс.

</details>

<details>
  <summary>Что такое ETag и как он работает?</summary>

ETag — это уникальный идентификатор версии ресурса. Браузер отправляет ETag при повторном запросе, и если ресурс не изменился, сервер возвращает 304 Not Modified.

</details>

<details>
  <summary>Как можно кешировать результаты SSR?</summary>

Можно сохранять сгенерированные HTML-страницы в памяти, на диске или в стороннем кеше (Redis, Memcached) и отдавать их при повторных запросах, чтобы не рендерить заново.

</details>

<details>
  <summary>Как сбросить или обновить кеш?</summary>

1. Изменение URL или имени файла (Cache Busting)
   - Самый надёжный способ для статических файлов (CSS, JS, изображения).
   - При каждом изменении файла к его имени добавляют уникальный идентификатор (обычно хеш содержимого или версию).
   - Пример:
     Было: /main.css
     Стало: /main.4f3a2b.css
   - Браузер видит новый URL и загружает свежий файл, старый кеш больше не используется.
2. Изменение заголовков Cache-Control
   - Можно уменьшить время жизни кеша (max-age), чтобы браузер чаще проверял актуальность ресурса.
   - Можно временно выставить no-cache или no-store, чтобы принудительно отключить кеширование.
3. Сброс кеша на сервере или CDN
   - Многие CDN (Cloudflare, Akamai и др.) и прокси-серверы позволяют вручную сбросить кеш через панель управления или API.
   - Можно сбросить кеш для одного файла или для всего сайта.
4. Использование заголовков ETag и Last-Modified
   - Если содержимое изменилось, сервер должен отдавать новый ETag или новую дату в Last-Modified.
   - Тогда браузер поймёт, что ресурс обновился, и загрузит новую версию.
5. Программный сброс кеша

   - В приложениях можно реализовать ручной сброс кеша (например, кнопка "Обновить данные" вызывает запрос с параметром, который обходит кеш).
   - Для API-запросов можно добавлять уникальный query-параметр:

     /api/data?ts=1680000000

     Это заставит браузер и прокси считать запрос уникальным.

6. Очищение кеша в браузере
   - Пользователь может вручную очистить кеш через настройки браузера (но это крайний случай).

Итог

- Для статики — меняйте имя файла при каждом изменении.
- Для динамики — корректно обновляйте ETag/Last-Modified, используйте короткий max-age.
- Для CDN — используйте инструменты сброса кеша.
- Для ручного контроля — добавляйте уникальные параметры к запросам.
</details>

<br>

## Clean code

<details>
  <summary>Что такое SOLID?</summary>
  
  - Single responsibility (принцип единственной ответственности)
    обозначает, что каждый объект должен иметь одну обязанность и эта обязанность должна быть полностью инкапсулирована в класс. Все его сервисы должны быть направлены исключительно на обеспечение этой обязанности.

- Open-closed (принцип открытости / закрытости)
  программные сущности (классы, модули, функции и т. п.) должны быть открыты для расширения, но закрыты для изменения. Это означает, что эти сущности могут менять свое поведение без изменения их исходного кода.
- Принцип подстановки Барбары Лисков (Liskov substitution principle / LSP)
  Наследующий класс должен дополнять, а не замещать поведение базового класса.

- Принцип разделения интерфейса (interface segregation principle / ISP)
  слишком «толстые» интерфейсы необходимо разделять на более маленькие и специфические, чтобы клиенты маленьких интерфейсов знали только о методах, которые необходимы им в работе. В итоге, при изменении метода интерфейса не должны меняться клиенты, которые этот метод не используют.
- Принцип инверсии зависимостей (dependency inversion principle / DIP)
  модули верхних уровней не должны зависеть от модулей нижних уровней, а оба типа модулей должны зависеть от абстракций; сами абстракции не должны зависеть от деталей, а вот детали должны зависеть от абстракций.

  Например, мы реализуем хранение документов в веб-приложении. На первый взгляд, кажется логичным добавить зависимость от модулей работы с файловой системой непосредственно в класс, отвечающий за высокоуровневую работу с этими документами. Но в перспективе такая зависимость может создать проблемы — например, нам потребуется хранить данные не только на диске, но и в облаке. Если зависимость внедрена от реализации, то мы столкнёмся с необходимостью её переработки. Если же зависимость выведена на уровень абстракции (интерфейса), то нам будет достаточно реализовать функционал работы с облаком, соответствующий ранее созданному интерфейсу работы с файлами.

Источник: [web-creator.ru](https://web-creator.ru/articles/solid)

</details>

<details>
  <summary>Что такое KISS (keep it simple, stupid)?</summary>

KISS — это принцип проектирования и программирования, при котором простота системы декларируется в качестве основной цели или ценности.

В программировании следование принципу KISS можно описать так:

- не имеет смысла беспредельно увеличивать уровень абстракции, надо уметь вовремя остановиться;
- бессмысленно закладывать в проект избыточные функции «про запас», которые может быть когда-нибудь кому-либо понадобятся (тут скорее правильнее подход согласно принципу YAGNI);
- не стоит подключать огромную библиотеку, если вам от неё нужна лишь пара функций;
- декомпозиция чего-то сложного на простые составляющие — это архитектурно верный подход (тут KISS перекликается с DRY);
- абсолютная математическая точность или предельная детализация нужны не всегда — большинство систем создаются не для запуска космических шаттлов, данные можно и нужно обрабатывать с той точностью, которая достаточна для качественного решения задачи, а детализацию выдавать в нужном пользователю объёме, а не в максимально возможном объёме.

Источник: [web-creator.ru](https://web-creator.ru/articles/kiss)

</details>

<details>
  <summary>Что такое YAGNI (You Ain't Gonna Need It)?</summary>

Если упрощенно, то следование данному принципу заключается в том, что возможности, которые не описаны в требованиях к системе, просто не должны реализовываться.

Источник: [web-creator.ru](https://web-creator.ru/articles/yagni)

</details>

<details>
  <summary>Что такое DRY (Don't repeat yourself)?</summary>

Не повторяйте написанный код!

Источник: [web-creator.ru](https://web-creator.ru/articles/yagni)

</details>
<br>

## CSS

<details>
  <summary>Что такое селекторы?</summary>
  <br>
  <p>Селектор определяет, к какому элементу применять то или иное CSS-правило.</p>
  <span>Основных видов селекторов всего несколько:</span>
  <ul>
    <li>* – любые элементы.</li>
    <li>div – элементы с таким тегом.</li>
    <li>#id – элемент с данным id.</li>
    <li>.class – элементы с таким классом.</li>
    <li>[name="value"] – селекторы на атрибут</li>
    <li>:visited – «псевдоклассы», остальные разные условия на элемент</li>
  </ul>
  <br>
  <p><i>Источник: <a href='https://learn.javascript.ru/css-selectors'>javascript.ru</a></i></p>
</details>

<details>
  <summary>Что такое спецефичность селекторов?</summary>
  <br>
  <p>Специфичность - это способ, с помощью которого браузеры определяют, какие значения свойств CSS наиболее
    соответствуют элементу и, следовательно, будут применены.</p>
  <span>Спецефичность селекторов:</span>
  <table>
    <tbody>
      <tr>
        <td>Селектор тега:</td>
        <td>1</td>
      </tr>
      <tr>
        <td>Селектор класса:</td>
        <td>10</td>
      </tr>
      <tr>
        <td>Селектор ID:</td>
        <td>100</td>
      </tr>
      <tr>
        <td>Inline-стиль:</td>
        <td>1000</td>
      </tr>
    </tbody>
  </table>
  <p><i>Источник: <a href='https://developer.mozilla.org/ru/docs/Web/CSS/Specificity'>developer.mozilla.org</a></i></p>
</details>

<details>
  <summary>Что такое вложенные селекторы?</summary>
  <br>
  <p>В HTML можно вписать одни теги в другие. В CSS мы можем выбирать те теги, которые вложены в какой-либо тег. Для
    этого используется конструкция вложенных селекторов (A B). Например, мы можем задать стили для всех em, которые
    находятся в тегах div.</p>
  <code>
    #example em {
      color: #cc4d4d;
    }
  </code>
  <p><i>Источник: <a href='https://developer.mozilla.org/ru/docs/Web/CSS/Specificity'>developer.mozilla.org</a></i></p>
</details>

<details>
  <summary>Что такое семантическая вёрстка и зачем она нужна?</summary>
  <br>
  <ul>
    <li>Чтобы сделать сайт доступным. Зрячие пользователи могут без проблем с первого взгляда понять, где какая часть
      страницы находится — где заголовок, списки или изображения. Для незрячих или плохо видящих основной инструмент для
      просмотра сайтов не браузер, который отрисовывает страницу, а скринридер, который читает текст со страницы вслух.
    </li>
    <li>Чтобы сайт был выше в поисковиках. Наличие семантической разметки страниц помогает поисковым ботам лучше
      понимать, что находится на странице, и в зависимости от этого ранжировать сайты в поисковой выдаче.</li>
    <li>Tags: article, section, aside, nav, header, main, footer, h1-h6, ul...</li>
</details>

<details>
  <summary>Position</summary>
  <ul>
    <li>
      <span>static</span>
      <p>static ещё называют не позиционированным(отпозиционированы статически, то есть никак).</p>>
    </li>
    <li>
      <span>relative</span>
      <p>Относительное позиционирование сдвигает элемент относительно его обычного положения.</p>>
    </li>
    <li>
      <span>absolute</span>
      <p>Абсолютное позиционирование делает две вещи: Элемент исчезает с того места, где он должен быть и позиционируется заново и Координаты top/bottom/left/right для нового местоположения отсчитываются от ближайшего позиционированного родителя.</p>>
    </li>
    <li>
      <span>fixed</span>
      <p>Позиционирует объект точно так же, как absolute, но относительно window.</p>>
      <p>Когда страницу прокручивают, фиксированный элемент остаётся на своём месте и не прокручивается вместе со страницей.</p>
    </li>
    <li>
      <span>sticky </span>
      <p>sticky может перемещаться только в пределах контейнера, в котором находится.</p>>
    </li>
  </ul>
</details>

<details>
  <summary>display</summary>
  <ul>
    <li>
      <span>none</span>
      <p>Элемент не показывается, вообще. Как будто его и нет.</p>
    </li>
    <li>
      <span>block</span>
      <p>Блочные элементы располагаются один над другим, вертикально (если нет особых свойств позиционирования, например float).</p>
      <p>Блок стремится расшириться на всю доступную ширину. Можно указать ширину и высоту явно.</p>
    </li>
    <li>
      <span>inline</span>
      <p>Блочные элементы располагаются один над другим, вертикально (если нет особых свойств позиционирования, например float).
      </p>
      <p>Блок стремится расшириться на всю доступную ширину. Можно указать ширину и высоту явно.</p>
    </li>
    <li>
      <span>inline-block</span>
      <p>Это значение – означает элемент, который продолжает находиться в строке (inline), но при этом может иметь важные свойства блока.</p>
    </li>
    <li>
      <span>table-*</span>
      <p>Современные браузеры (IE8+) позволяют описывать таблицу любыми элементами, если поставить им соответствующие значения display.</p>
    </li>
    <li>
      <span>flex</span>
    </li>
    <li>
      <span>grid</span>
    </li>
  </ul>
</details>
<br>

## JavaScript

<details>
  <summary>Автобоксинг(Autoboxing) и Преобразование типов (Type Coercion)</summary>

#### Автобоксинг (Autoboxing):

- Это процесс автоматического преобразования примитивного типа в его объект-обертку
- Происходит только для примитивных типов (string, number, boolean, symbol)
- Создает временный объект-обертку для доступа к методам и свойствам
- После использования метода/свойства временный объект удаляется

Пример автобоксинга:

```javascript
let str = "hello";
console.log(str.length); // 5
// str временно преобразуется в String объект для доступа к свойству length
```

#### Преобразование типов (Type Coercion):

- Это процесс преобразования значения из одного типа в другой
- Может происходить между любыми типами данных
- Может быть явным (explicit) или неявным (implicit)
- Не создает временных объектов

Явное преобразование:

```javascript
// String to Number
let str = "123";
let num = Number(str); // 123

// Number to String
let num = 123;
let str = String(num); // "123"

// Boolean to Number
let bool = true;
let num = Number(bool); // 1
```

Неявное преобразование:

```javascript
// String + Number
console.log("2" + 2); // "22" (конкатенация)

// Number + Boolean
console.log(1 + true); // 2 (true преобразуется в 1)

// String to Number в сравнении
console.log("2" == 2); // true
```

</details>

<details>
  <summary>Что такое Hoisting?</summary>
  <br>
  <p>Поднятие или hoisting — это механизм в JavaScript, в котором переменные и объявления функций, передвигаются вверх своей области видимости перед тем, как код будет выполнен.</p>
  <p>JavaScript сначала объявляет, а уже затем инициализирует наши переменные.</p>
  <ul>
    <li>
      <span>var</span>
      <p>Областью видимости переменной, объявленной через var, является её настоящий контекст выполнения.</p>

```javascript
console.log(hoist); // Вывод: undefined
var hoist = "The variable has been hoisted.";
function hoist() {
  console.log(message);
  message = "Hoisting is all the rage!";
}
hoist(); // Вывод: undefined
```

  </li>
  <li>
    <span>let</span>
    <p>Переменные объявленные через let заключены в область видимости блока, а не функции.</p>
    <p>Вкратце, это просто говорит о том, что область видимости переменной привязана к блоку, в котором она объявлена, а не к функции в которой она объявлена.</p>
  
  ```javascript
    console.log(hoist); // Вывод: ReferenceError: hoist is not defined
    ...
    let hoist = 'The variable has been hoisted.';
  ```
  </li>
  <li>
    <span>const</span>
    <p>Const была представлена в es6 для того, чтобы можно было сделать неизменные переменные.</p>
  </li>
  <p>Переменные объявленные с let и const остаются неинициализированными в начале выполнения, в то время как переменные объявленные с var инициализируются со значением undefined.</p>
  <br>
  <b>Поднятие функций</b>
  <span>Объявленные функции</span>
  <p>Такие функции полностью поднимаются вверх кода.</p>

```javascript
hoisted(); // Вывод: "This function has been hoisted."
function hoisted() {
  console.log("This function has been hoisted.");
}
```

  <p>Функциональные выражения, однако, не поднимаются.</p>
  <code>

```javascript
expression(); //Вывод: "TypeError: expression is not a function
var expression = function () {
  console.log("Will this work?");
};
```

  </code>
  <p>1. Используя es5 переменную var, попытки использования необъявленных переменных приведут к тому, что переменной будет назначено значение undefined при «поднятии».</p>
  <p>2. Используя переменные es6 let и const, использование переменных приведет к Reference Error, потому что переменная останется неинициализированной при выполнении.</p>
  <p><i>Источник: <a href='https://medium.com/@stasonmars/%D1%80%D0%B0%D0%B7%D0%B1%D0%B8%D1%80%D0%B0%D0%B5%D0%BC%D1%81%D1%8F-%D1%81-%D0%BF%D0%BE%D0%B4%D0%BD%D1%8F%D1%82%D0%B8%D0%B5%D0%BC-hoisting-%D0%B2-javascript-7d2d27bc51f1'>medium.com</a></i></p>
</details>

<details>
  <summary>Что такое Temporal Dead Zone?</summary>

Термин, описывающий состояние, в котором переменные недоступны.

</details>

<details>
  <br>
  <summary>Что такое this?</summary>
  <p>This — это ключевое слово, используемое в JavaScript, которое имеет особое значение, зависящее от контекста в котором оно применяется.</p>
  <h3>Ситуации, когда this указывает на объект window</h3>
  <p>Если вы попытаетесь обратиться к ключевому слову this в глобальной области видимости, оно будет привязано к глобальному контексту, то есть — к объекту window в браузере.</p>
  <h3>Использование this внутри объекта</h3>
  <p>Когда this используется внутри объекта, это ключевое слово ссылается на сам объект. Рассмотрим пример. Предположим, вы создали объект dog с методами и обратились в одном из его методов к this. Когда this используется внутри этого метода, это ключевое слово олицетворяет объект dog.</p>
  <h3>This и вложенные объекты</h3>
  <p>Применение this во вложенных объектах может создать некоторую путаницу. В подобных ситуациях стоит помнить о том, что ключевое слово this относиться к тому объекту, в методе которого оно используется. </p>
  <h3>Особенности стрелочных функций</h3>
  <p>Стрелочные функции ведут себя не так, как обычные функции. Вспомните: при обращении к this в методе объекта, этому ключевому слову соответствует объект, которому принадлежит метод. Однако это не относится к стрелочным функциям. Вместо этого, this в таких функциях относится к глобальному контексту (к объекту window).</p>
  <p><i>Источник: <a href='https://habr.com/ru/company/ruvds/blog/419371/'>habr.com</a></i></p>
</details>

<details>
<summary>Apply, call, bind. Для чего используются? В чем отличия?</summary>

- _call_

Метод call() вызывает функцию с указанным значением this и индивидуально предоставленными аргументами. Вы можете присваивать различные объекты this при вызове существующей функции. this ссылается на текущий объект, вызвавший объект. С помощью call вы можете написать метод один раз, а затем наследовать его в других объектах, без необходимости переписывать метод для каждого нового объекта.

```javascript
function showFullName() {
  alert(this.firstName + " " + this.lastName);
}

const user = {
  firstName: "Василий",
  lastName: "Петров",
};

// функция вызовется с this=user
showFullName.call(user); // "Василий Петров"
```

- _apply_

Метод apply() вызывает функцию с указанным значением this и аргументами, предоставленными в виде массива (либо массивоподобного объекта). Вы можете присваивать различные объекты this при вызове существующей функции. this ссылается на текущий объект, вызывающий объект. С помощью apply() вы можете написать метод один раз, а затем наследовать его в других объектах без необходимости переписывать метод для каждого нового объекта.

```javascript
//эти две строчки сработают одинаково:
showFullName.call(user, "firstName", "surname");
showFullName.apply(user, ["firstName", "surname"]);
```

```javascript
var arr = [];
arr.push(1);
arr.push(5);
arr.push(2);

// получить максимум из элементов arr
alert(Math.max.apply(null, arr)); // 5
```

Преимущество apply() перед call() отчётливо видно, когда мы формируем массив аргументов динамически.

- _bind_

Метод bind() создаёт новую функцию, которая при вызове устанавливает в качестве контекста выполнения this предоставленное значение. В метод также передаётся набор аргументов, которые будут установлены перед переданными в привязанную функцию аргументами при её вызове.

```javascript
// Пример потери контекста
var user = {
  firstName: "Вася",
  sayHi: function () {
    alert(this.firstName);
  },
};

setTimeout(user.sayHi, 1000); // undefined (не Вася!)
```

```javascript
// привязка контекста
var user = {
  firstName: "Вася",
  sayHi: function () {
    alert(this.firstName);
  },
};

setTimeout(user.sayHi.bind(user), 1000); // Вася
```

Вызов bind часто используют для привязки функции к контексту, чтобы затем присвоить её в обычную переменную и вызывать уже без явного указания объекта.

- фундаментальное различие между этими методами заключается в том, что функция call() принимает список аргументов, в то время, как функция apply() - одиночный массив аргументов. Методы call/apply вызывают функцию с заданным контекстом и аргументами. А bind не вызывает функцию. Он только возвращает «обёртку», которую мы можем вызвать позже, и которая передаст вызов в исходную функцию, с привязанным контекстом.

Подробнее:

https://learn.javascript.ru/call-apply

https://learn.javascript.ru/bind

</details>

<details>
  <summary>Методы массива, перебирающие элементы массива</summary>

- _forEach_
  Метод «Array.prototype.forEach(callback[, thisArg])» используется для перебора массива.
  Он для каждого элемента массива вызывает функцию callback.
  Этой функции он передаёт три параметра callback(item, i, arr):

item – очередной элемент массива.

i – его номер.

arr – массив, который перебирается.

Например:

```javascript
let arr = ["Яблоко", "Апельсин", "Груша"];

arr.forEach(function (item, i, arr) {
  alert(i + ": " + item + " (массив:" + arr + ")");
});
```

Второй, необязательный аргумент forEach позволяет указать контекст this для callback.
Метод forEach ничего не возвращает, его используют только для перебора, как более «элегантный» вариант, чем обычный цикл for.

- _filter_
  Метод «Array.prototype.filter(callback[, thisArg])» используется для фильтрации массива через функцию.
  Он создаёт новый массив, в который войдут только те элементы arr, для которых вызов callback(item, i, arr) возвратит true.

Например:

```javascript
let arr = [1, -1, 2, -2, 3];

let positiveArr = arr.filter(function (number) {
  return number > 0;
});

alert(positiveArr); // 1,2,3
```

- _map_
  Метод «Array.prototype.map(callback[, thisArg])» используется для трансформации массива.
  Он создаёт новый массив, который будет состоять из результатов вызова callback(item, i, arr) для каждого элемента arr.

Например:

```javascript
let names = ["HTML", "CSS", "JavaScript"];

let nameLengths = names.map(function (name) {
  return name.length;
});

// получили массив с длинами
alert(nameLengths); // 4,3,10
```

- _every/some_

Эти методы используются для проверки массива.

Метод «Array.prototype.every(callback[, thisArg])» возвращает true, если вызов callback вернёт true для каждого элемента arr.
Метод «Array.prototype.some(callback[, thisArg])» возвращает true, если вызов callback вернёт true для какого-нибудь элемента arr.

```javascript
let arr = [1, -1, 2, -2, 3];

function isPositive(number) {
  return number > 0;
}

alert(arr.every(isPositive)); // false, не все положительные
alert(arr.some(isPositive)); // true, есть хоть одно положительное
```

- _reduce/reduceRight_

Метод «Array.prototype.reduce(callback[, initialValue])» используется для последовательной обработки каждого элемента массива с сохранением промежуточного результата.
Метод reduce используется для вычисления на основе массива какого-либо единого значения, иначе говорят «для свёртки массива». Чуть далее мы разберём пример для вычисления суммы.
Он применяет функцию callback по очереди к каждому элементу массива слева направо, сохраняя при этом промежуточный результат.

Аргументы функции callback(previousValue, currentItem, index, arr):

previousValue – последний результат вызова функции, он же «промежуточный результат».
currentItem – текущий элемент массива, элементы перебираются по очереди слева-направо.

index – номер текущего элемента.

arr – обрабатываемый массив.

Кроме callback, методу можно передать «начальное значение» – аргумент initialValue. Если он есть, то на первом вызове значение previousValue будет равно initialValue, а если у reduce нет второго аргумента, то оно равно первому элементу массива, а перебор начинается со второго.

Пример:

```javascript
let arr = [1, 2, 3, 4, 5];

// для каждого элемента массива запустить функцию,
// промежуточный результат передавать первым аргументом далее
let result = arr.reduce(function (sum, current) {
  return sum + current;
}, 0);

alert(result); // 15
```

При первом запуске sum – исходное значение, с которого начинаются вычисления, равно нулю (второй аргумент reduce).
Сначала анонимная функция вызывается с этим начальным значением и первым элементом массива, результат запоминается и передаётся в следующий вызов, уже со вторым аргументом массива, затем новое значение участвует в вычислениях с третьим аргументом и так далее.

Подробнее:

https://learn.javascript.ru/array-iteration

https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach

https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/filter

https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/map

https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/every

https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/some

https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce

</details>

<details>
  <summary>Мутирующие и не мутирующие методы массивов
</summary>

## Мутирующие методы массивов

Эти методы изменяют исходный массив:

- push() — добавляет элементы в конец массива.
- pop() — удаляет последний элемент массива.
- shift() — удаляет первый элемент массива.
- unshift() — добавляет элементы в начало массива.
- splice() — добавляет, удаляет или заменяет элементы в массиве.
- sort() — сортирует элементы массива.
- reverse() — меняет порядок элементов на обратный.
- fill() — заполняет все элементы массива одним значением.
- copyWithin() — копирует часть массива внутри самого массива.

## Не мутирующие методы массивов

Эти методы не изменяют исходный массив, а возвращают новый массив или значение:

- concat() — объединяет массивы, возвращает новый массив.
- slice() — возвращает новый массив, содержащий копию части исходного.
- map() — возвращает новый массив, результат применения функции к каждому элементу.
- filter() — возвращает новый массив, содержащий элементы, прошедшие проверку.
- reduce() — возвращает одно значение, не изменяет массив.
- reduceRight() — аналогично reduce, но справа налево.
- find() — возвращает первый элемент, удовлетворяющий условию (или undefined).
- findIndex() — возвращает индекс первого подходящего элемента (или -1).
- includes() — проверяет, содержит ли массив определённый элемент.
- indexOf() — возвращает первый индекс элемента (или -1).
- lastIndexOf() — возвращает последний индекс элемента (или -1).
- join() — объединяет все элементы массива в строку.
- toString() — возвращает строковое представление массива.
- every() — проверяет, удовлетворяют ли все элементы условию.
- some() — проверяет, удовлетворяет ли хотя бы один элемент условию.
- flat() — возвращает новый массив с "разглаженными" вложенными массивами.
- flatMap() — сначала применяет функцию, затем "разглаживает" результат.

</details>

<details>
  <summary>Promises</summary>

Для того чтобы поиграться с запросами, можно использовать открытый API http://jsonplaceholder.typicode.com/

Объект Promise (обещание) используется для отложенных и асинхронных вычислений. Promise может находиться в трёх состояниях:

- ожидание (pending): начальное состояние, не выполнено и не отклонено.
- выполнено (fulfilled): операция завершена успешно.
- отклонено (rejected): операция завершена с ошибкой.

```javascript
// Создаётся объект promise
let promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    // переведёт промис в состояние fulfilled с результатом "result"
    resolve("result");
  }, 1000);
});

// promise.then навешивает обработчики на успешный результат или ошибку
promise.then(
  (result) => {
    // первая функция-обработчик - запустится при вызове resolve
    alert("Fulfilled: " + result); // result - аргумент resolve
  },
  (error) => {
    // вторая функция - запустится при вызове reject
    alert("Rejected: " + error); // error - аргумент reject
  }
);
```

Методы:

- Promise.all - Ожидает выполнения всех промисов в массиве. Если хотя бы один промис rejected — возвращает ошибку.
- Promise.race - Возвращает результат первого завершившегося промиса (fulfilled или rejected).
- Promise.allSettled - Ожидает завершения всех промисов, возвращает массив объектов с результатами для каждого промиса (fulfilled или rejected).
- Promise.any - Ожидает первый успешно завершившийся промис (fulfilled). Если все промисы rejected — возвращает ошибку.

https://learn.javascript.ru/promise
https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Promise

</details>

<details>
  <summary>Prototype. Отличия proto от prototype. Пример наследования</summary>
  
Объекты в JavaScript можно организовать в цепочки так, чтобы свойство, не найденное в одном объекте, автоматически искалось бы в другом.
Связующим звеном выступает специальное свойство __proto__.
Если один объект имеет специальную ссылку __proto__ на другой объект, то при чтении свойства из него, если свойство отсутствует в самом объекте, оно ищется в объекте __proto__.
```javascript
var animal = {
  eats: true
};
var rabbit = {
  jumps: true
};

rabbit.**proto** = animal;

// в rabbit можно найти оба свойства
console.log( rabbit.jumps ); // true
console.log( rabbit.eats ); // true

````
Объект, на который указывает ссылка __proto__, называется «прототипом». В данном случае получилось, что animal является прототипом для rabbit.
У объекта, который является __proto__, может быть свой __proto__, у того – свой, и так далее. При этом свойства будут искаться по цепочке.
__proto__ не работает в IE10.
К счастью, в JavaScript с древнейших времён существует альтернативный, встроенный в язык и полностью кросс-браузерный способ.
Чтобы новым объектам автоматически ставить прототип, конструктору ставится свойство prototype.
При создании объекта через new, в его прототип __proto__ записывается ссылка из prototype функции-конструктора.

Например, код ниже полностью аналогичен предыдущему, но работает всегда и везде:

```javascript
let animal = {
  eats: true
};

function Rabbit(name) {
  this.name = name;
}

Rabbit.prototype = animal;

let rabbit = new Rabbit("Кроль"); //  rabbit.__proto__ == animal

alert( rabbit.eats ); // true
````

Установка Rabbit.prototype = animal буквально говорит интерпретатору следующее: "При создании объекта через new Rabbit запиши ему **proto** = animal".
Свойство prototype имеет смысл только у конструктора
Свойство с именем prototype можно указать на любом объекте, но особый смысл оно имеет, лишь если назначено функции-конструктору.
Само по себе, без вызова оператора new, оно вообще ничего не делает, его единственное назначение – указывать **proto** для новых объектов.

Пример наследования:

```javascript
// 1. Конструктор Animal
function Animal(name) {
  this.name = name;
  this.speed = 0;
}

// 1.1. Методы -- в прототип

Animal.prototype.stop = function () {
  this.speed = 0;
  alert(this.name + " стоит");
};

Animal.prototype.run = function (speed) {
  this.speed += speed;
  alert(this.name + " бежит, скорость " + this.speed);
};

// 2. Конструктор Rabbit
function Rabbit(name) {
  this.name = name;
  this.speed = 0;
  1;
}

// 2.1. Наследование
Rabbit.prototype = Object.create(Animal.prototype);
Rabbit.prototype.constructor = Rabbit;

// 2.2. Методы Rabbit
Rabbit.prototype.jump = function () {
  this.speed++;
  alert(this.name + " прыгает, скорость " + this.speed);
};
```

Подробнее:

http://learn.javascript.ru/class-inheritance

http://learn.javascript.ru/prototype

http://learn.javascript.ru/new-prototype

</details>

<details>
  <summary>Что такое ЗАМЫКАНИЕ?</summary>
  <br>
  <p>Замыкание это функция у которой есть доступ к своей внешней функции по области видимости, даже после того, как внешняя функция прекратилась. Это говорит о том, что замыкание может запоминать и получать доступ к переменным, и аргументам своей внешней функции, даже после того, как та прекратит выполнение.</p>
  <code>

    function getCounter() {
      let counter = 0;
      return function() {
        return counter++;
      }
    }
    let count = getCounter();
    console.log(count());  // 0
    console.log(count());  // 1
    console.log(count());  // 2

  </code>
  <p>Мы храним анонимную внутреннюю функцию, возвращенную функцией getCounter в переменной count. Так как функция сount теперь замыкание, она может получать доступ к переменной counter в функции getCounter, даже после того, как та завершится.</p>
  <p>Но обратите внимание, что значение counter не сбрасывается до 0 при каждом вызове count, как вроде бы она должна делать.
  </p>
  <p>Так происходит, потому что при каждом вызове count(), создаётся новая область видимости, но есть только одна область видимости, созданная для getCounter, так как переменная counter объявлена в области видимости getCounter(), она увеличится при каждом вызове функции count, вместо того, чтобы сброситься до 0.</p>
  <p><i>Источник: <a href='https://medium.com/@stasonmars/%D0%BF%D0%BE%D0%BD%D0%B8%D0%BC%D0%B0%D0%B5%D0%BC-%D0%B7%D0%B0%D0%BC%D1%8B%D0%BA%D0%B0%D0%BD%D0%B8%D1%8F-%D0%B2-javascript-%D1%80%D0%B0%D0%B7-%D0%B8-%D0%BD%D0%B0%D0%B2%D1%81%D0%B5%D0%B3%D0%B4%D0%B0-c211805b6898'>medium.com</a></i></p>
</details>

<details>
  <summary>Что такое контекст выполнения?</summary>
  <br>
  <p>Это абстрактная среда, в которой JavaScript код оценивается и выполняется. Когда выполняется "глобальный" код, он выполняется внутри глобального контекста выполнения, а код функции выполняется внутри контекста выполнения функции.</p>
  <img src="https://miro.medium.com/max/875/1*huMb5-_MmM8zkFVnchsjbg.png" alt="">
  <p>Во время выполнения этого кода, движок JavaScript создаёт глобальный контекст вызова, для того, чтобы выполнить глобальный код и когда он доходит до вызова функции first(), он создаёт новый контекст выполнения для этой функции и ставит её на вершину стека вызовов.</p>
  <p>Когда функция first() завершится, её стек выполнения удалится и начнется выполнение кода ниже. Так что оставшийся код в глобальной области видимости будет выполнен.</p>
  <p><i>Источник: <a href='https://medium.com/@stasonmars/%D0%BF%D0%BE%D0%BD%D0%B8%D0%BC%D0%B0%D0%B5%D0%BC-%D0%B7%D0%B0%D0%BC%D1%8B%D0%BA%D0%B0%D0%BD%D0%B8%D1%8F-%D0%B2-javascript-%D1%80%D0%B0%D0%B7-%D0%B8-%D0%BD%D0%B0%D0%B2%D1%81%D0%B5%D0%B3%D0%B4%D0%B0-c211805b6898'>medium.com</a></i></p>
</details>

<details>
  <summary>Что такое лексическое окружение?</summary>
  <br>
  <p>Каждый раз, когда движок JavaScript создаёт контекст выполнения, чтобы выполнить функцию или глобальный код, он также создаёт новое лексическое окружение, чтобы хранить переменную определенную в этой функции во время её выполнения.
  </p>
  <p>Лексическое окружение это структура данных, которая хранит информацию по идентификаторам переменных. Тут идентификатор обозначает имя переменных/функций, а переменная настоящий объект[включая тип функции] или примитивное значение.</p>
  <span>У лексического окружения есть два компонента: (1) запись в окружении и (2) отсылка к внешнему окружению.</span>
  <ul>
    <li>Запись в окружении(environment record) это место хранятся объявления переменной или функции.</li>
    <li>Отсылка к внешнему окружению (reference to the outer environment) означает то, что у него есть доступ к внешнему (родительскому) лексическому окружению. Этот компонент самый важный для понимания того, как работают замыкания.</li>
  </ul>
  <p><b>Обратите внимание</b> — когда функция выполняется, её контекст выполнения удаляется из стека, но её лексическое окружение может или не может быть удалено из памяти, в зависимости от того, ссылается ли на это лексическое окружение другое лексическое окружение.</p>
  <p><i>Источник: <a href='https://medium.com/@stasonmars/%D0%BF%D0%BE%D0%BD%D0%B8%D0%BC%D0%B0%D0%B5%D0%BC-%D0%B7%D0%B0%D0%BC%D1%8B%D0%BA%D0%B0%D0%BD%D0%B8%D1%8F-%D0%B2-javascript-%D1%80%D0%B0%D0%B7-%D0%B8-%D0%BD%D0%B0%D0%B2%D1%81%D0%B5%D0%B3%D0%B4%D0%B0-c211805b6898'>medium.com</a></i></p>
</details>

<details>
  <summary>Разница межды func expression и declaration?</summary>
  <p>Function Declaration - функция, объявленная в основном потоке кода.</p>
  <p>Function Expression - объявление функции в контексте какого-либо выражения, например присваивания.</p>

```javascript
// Function Declaration
sayHi("Вася"); // Привет, Вася

function sayHi(name) {
  console.log("Привет, " + name);
}

// Function Expression
sayHi("Вася"); // ошибка!

var sayHi = function (name) {
  console.log("Привет, " + name);
};
```

  <p>Основное отличие между ними: функции, объявленные как Function Declaration, создаются интерпретатором до выполнения кода.</p>
  <p>Это из-за того, что JavaScript перед запуском кода ищет в нём Function Declaration (их легко найти: они не являются частью выражений и начинаются со слова function) и обрабатывает их. А Function Expression создаются в процессе выполнения выражения, в котором созданы, в данном случае – функция будет создана при операции присваивания sayHi = function...</p>
</details>

<details>
  <summary>Разница между обычными функциями и стрелочными</summary>
  <br>
  <ul>
    <li>
      <h3>this</h3>
      <p><b>Обыкновенные функции</b></p>
      <p>Внутри обыкновенной функции значение this динамическое (в зависимости от контекста исполнения).</p>
      <p>Динамический контекст означает, что значение this зависит от того как была вызвана функция. В JS существует 4е способа как ты можешь вызвать функцию.</p>
      <ul>
        <li>Во время обычного выполнения значение this эквивалентно глобальному объекту window.</li>
        <li>Во время выполнения функции объекта значением this является объект, у которого был вызван метод.</li>
        <li>Косвенный вызов используя myFunc.call(thisVal, arg1, ..., argN) или myFunc.apply(thisVal, [arg1, ..., argN]), значение this эквивалентно первому аргументу.</li>
        <li>Вызов с помощью конструктора используя ключевое слово new, значение this эквивалентно новосозданной сущности.</li>
      </ul>
      <p><b>Стрелочные функции</b></p>
      <p>Не имеет значения как она была вызвана, значение this внутри стрелочной функции всегда эквивалентно значения this внешней функции. Функция не создает собственный контекст исполнения, она использует внешний.</p>
    </li>
    <li>
      <h3>Конструкторы</h3>
      <p><b>Обыкновенные функции</b></p>
      <p>Обычная функция может легко создавать объекты, через конструктор new.</p>
      <p><b>Стрелочные функции</b></p>
      <p>Как следствие того, что стрелочные функции не имеют собственного this они не могут быть использованы для создания объектов.Если ты попытаешься вызвать стрелочную функцию с использованием ключевого слова new, JS кинет TypeError.</p>
    </li>
    <li>
      <h3>Объект arguments</h3>
      <p><b>Обыкновенные функции</b></p>
      <p>Внутри тела обыкновенной функции, существует специальный массив arguments содержащий список аргументов с которым функция была вызвана.</p>
      <code>

        function myFunction() {
          console.log(arguments);
        }

        myFunction('a', 'b'); // { 0: 'a', 1: 'b'}

  </code>
      <p><b>Стрелочные функции</b></p>
      <p>В стрелочных функциях отсутствует специальное слово arguments.Опять, точно так же, как и со значение this массив arguments для стрелочных функций будет браться из внешней функции.</p>
      <code>

        function myRegularFunction() {
          const myArrowFunction = () => {
            console.log(arguments);
          }
          myArrowFunction('c', 'd');
        }

        myRegularFunction('a', 'b'); // { 0: 'a', 1: 'b' }

  </code>
    </li>
    <li>
      <h3>Неявный return</h3>
      <p>Обыкновенные функции</p>
      <p>Только использование выражения return возвращает результат выполнения функции.</p>
      <p>Стрелочные функции</p>
      <p>Если стрелочная функция содержит в теле одну инструкцию, и ты опустил фигурные скобки, тогда выражение будет возвращено автоматически.</p>
    </li>
    <li>
      <h3>Методы</h3>
      <p>Можно использовать стрелочные функции как методы, внутри класса.</p>
    </li>
  </ul>
  <p>Значение this внутри обыкновенной функции динамически зависит от контекста вызова. Собственный this внутри стрелочной функции отсутствует и она ссылается на this внешней функции. Массив arguments внутри обыкновенной функции содержит список аргументов функции. Стрелочная функция, не имеет массива arguments (но ты можешь использовать деструктуризацию, для иммитации аналога ...args).Если в стрелочной функции содержится одна инструкция, то ты можешь использовать неявный return, даже без использования ключевого слова return. Последнее в списке, но не по важности - ты можешь использовать синтаксис стрелочных функций для внутри класса. При этом в качестве this будет выступать объект класса.</p>
  <p><i>Источник: <a href='https://vc.ru/dev/133379-5-otlichiy-mezhdu-obychnymi-i-strelochnymi-funkciyami'>vc.ru</a></i></p>
</details>

<details>
  <summary>Что такое рекурсия?</summary>

Рекурсия – это термин в программировании, означающий вызов функцией самой себя. Рекурсивные функции могут быть использованы для элегантного решения определённых задач.

Когда функция вызывает саму себя, это называется шагом рекурсии. База рекурсии – это такие аргументы функции, которые делают задачу настолько простой, что решение не требует дальнейших вложенных вызовов.

Рассмотрим два способа её реализации.

Итеративный способ: цикл for:

```javascript
function pow(x, n) {
  let result = 1;

  // умножаем result на x n раз в цикле
  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}

alert(pow(2, 3)); // 8
```

Рекурсивный способ: упрощение задачи и вызов функцией самой себя:

```javascript
function pow(x, n) {
  if (n == 1) {
    return x;
  } else {
    return x * pow(x, n - 1);
  }
}

alert(pow(2, 3)); // 8
```

</details>

<details>
  <summary>Всплытие и перехват событий</summary>
  <br>

В JavaScript есть три фазы обработки событий:

1. Фаза погружения (capturing phase)
2. Фаза цели (target phase)
3. Фаза всплытия (bubbling phase)

Основной принцип всплытия:

При наступлении события обработчики сначала срабатывают на самом вложенном элементе, затем на его родителе, затем выше и так далее, вверх по цепочке вложенности.

![](https://learn.javascript.ru/article/event-bubbling/event-order-bubbling.png)

Самый глубокий элемент, который вызывает событие, называется «целевым» или «исходным» элементом и доступен как `event.target`.

Для остановки всплытия нужно вызвать метод `event.stopPropagation()`.

`stopPropagation` препятствует продвижению события дальше, но на текущем элементе все обработчики отработают.

Для того, чтобы не только предотвратить всплытие, но и останавить обработку событий на текущем элементе используется метод `event.stopImmediatePropagation()`

Чтобы отловить событие на фазе погружения, нужно использовать третий параметр метода addEventListener(), установив его в true. По умолчанию этот параметр равен false, что означает обработку события на фазе всплытия.

Если вам нужно обработать событие на обеих фазах (погружения и всплытия), вы можете добавить два обработчика:

```javascript
element.addEventListener(
  "click",
  function (e) {
    console.log("Capturing phase");
  },
  true
);

element.addEventListener(
  "click",
  function (e) {
    console.log("Bubbling phase");
  },
  false
);
```

Откройте данный пример:

[исходный код](https://github.com/mdn/learning-area/blob/master/javascript/building-blocks/events/show-video-box.html)

[пример](http://mdn.github.io/learning-area/javascript/building-blocks/events/show-video-box.html)

```javascript
video.onclick = function (e) {
  e.stopPropagation();
  video.play();
};
```

Подробнее:

[developer.mozilla.org](https://developer.mozilla.org/ru/docs/Learn/JavaScript/Building_blocks/%D0%A1%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D1%8F#%D0%92%D1%81%D0%BF%D0%BB%D1%8B%D1%82%D0%B8%D0%B5_%D0%B8_%D0%BF%D0%B5%D1%80%D0%B5%D1%85%D0%B2%D0%B0%D1%82_%D1%81%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D0%B9)

https://learn.javascript.ru/event-bubbling

</details>

<details>
  <summary>Что такое EventLoop?</summary>

![](https://joprblob.azureedge.net/site/blog/8e147efe-422d-42c3-bb51-61ca50d660dc/event.png)
![](https://miro.medium.com/max/1400/1*_0CnS0bHNX7HMBLri3gNng.gif)

### Основные понятия

- Макрозадачи (macrotasks):

  - setTimeout, setInterval
  - обработчики событий (например, click)
  - I/O (ввод-вывод)
  - рендеринг

- Микрозадачи (microtasks):

  - Promise.then, Promise.catch, Promise.finally
  - queueMicrotask
  - MutationObserver

## Как работает Event Loop

1. Call Stack (Стек вызовов)
   - Это структура данных, где хранятся все выполняющиеся функции.
     Когда вызывается функция, она помещается в стек. Когда выполнение функции заканчивается — она удаляется из стека.
2. APIs / Node APIs
   - Браузер или Node.js предоставляют асинхронные API (например, setTimeout, DOM Events, HTTP-запросы).
   - Когда вызывается асинхронная функция, она передается в Web API, а основной поток продолжает выполнение.
3. Callback Queue (Очередь задач/колбэков)
   - Когда асинхронная операция завершается, её callback помещается в очередь задач.
4. Event Loop
   - Event Loop постоянно проверяет: если Call Stack пуст, он берет первую задачу из Callback Queue и помещает её в Call Stack для выполнения.

## Как Event Loop обрабатывает микрозадачи и макрозадачи

1. Выполняется весь синхронный код (основной поток).
2. Event Loop проверяет, пуст ли Call Stack.
3. Если стек пуст:

   - Выполняются все микрозадачи из очереди microtask (по одной, пока очередь не опустеет).
   - Выполняется одна макрозадача из очереди macrotask (например, setTimeout).
   - После выполнения макрозадачи — снова выполняются все микрозадачи, если они появились.

4. Повторяется цикл: макрозадача → все микрозадачи → макрозадача → все микрозадачи и т.д.

</details>

<br>

## React

<details>
  <summary>Что такое REACT?</summary>

React — это JavaScript-библиотека для создания пользовательских интерфейсов. Основывается на идее декларативного программирования(состоит в описании конечного результата).

</details>

<details>
  <summary>Что такое JSX?</summary>

JSX расшифровывается как Java Script XML.
Это просто расширение для JavaScript, которое позволяет писать код, подобный XML, для простоты и элегантности, а затем вы транспилируете JSX через babel или ts в чистые вызовы функций JavaScript с помощью React.createElement.

</details>

<details>
  <summary>Что такое props?</summary>

Сокращенно от Properties. Входящие свойства в компонент. Они только для чтения и
их нельзя менять. Всегда идут от родителя к ребенку.

</details>

<details>
  <summary>Какие хуки есть в React</summary>
    Хуки:
    
    - useState;
    - useEffect;
    - useContext;
    - useReducer;
    - useMemo;
    - useCallback;
    - useRef;
    - useLayoutEffect;

</details>

<details>
  <summary>Контролируемые и неконтролируемые компоненты в React</summary>

## Неуправляемые компоненты

Они запоминают всё, что вы печатали. Затем вы можете получить их значение, используя ref.
Например, в обработчике onClick:

```javascript
class Form extends Component {
  handleSubmitClick = () => {
    const name = this._name.value;
    // do something with `name`
  };
  render() {
    return (
      <div>
        <input type="text" ref={(input) => (this._name = input)} />
        <button onClick={this.handleSubmitClick}>Sign up</button>
      </div>
    );
  }
}
```

Другими словами, вам необходимо «вытащить» значения из поля, когда вам это нужно. Это можно сделать при отправке формы.

Это самый простой способ реализации форм. Конечно, должны быть веские основания для его использования, а именно: самые простейшие формы либо во время изучения React.
Однако этот способ не такой гибкий, поэтому давайте лучше посмотрим на управляемые компоненты.

## Управляемые компоненты

Управляемый компонент принимает свое текущее значение в качестве пропсов, а также коллбэк для изменения этого значения. Вы можете сказать, что это более "реактивный" способ управления компонентом, однако это не означает, что вы всегда должны использовать этот метод.

```javascript
class Form extends Component {
  constructor() {
    super();
    this.state = {
      name: "",
    };
  }

  handleNameChange = (event) => {
    this.setState({ name: event.target.value });
  };

  render() {
    return (
      <div>
        <input
          type="text"
          value={this.state.name}
          onChange={this.handleNameChange}
        />
      </div>
    );
  }
}
```

<img src='https://i.imgur.com/D5u8pqE.png'>

</details>

<details>
  <summary>Что такое refs в React?</summary>

Сокращенно от References. Специальный атрибут, позволяющий получить доступ до
конкретного DOM элемента
Нужен для:

- Вызова анимаций
- Для задания фокуса или выделения текста
- Взаимодействия со сторонними библиотеками

</details>

<details>
  <summary>В чем разница между state и props?</summary>

state - структура данных, необходимая для изменения и отслеживания
пользовательских действий

props - набор конфигурации, поступающий от родительского элемента. Их нельзя
изменять

</details>

<details>
  <summary>В чем смысл специального атрибута key?</summary>

Атрибут позволяет React понимать, какие именно элементы в списке были
модифицированы или удалены, что увеличивает производительность рендеринга.

Лучше всего использовать уникальные значения, такие как ID. Индексы использовать
не рекомендуется

</details>

<details>
  <summary>Какие методы жизненного цикла компонента существуют в React?</summary>
  
- render() — единственный обязательный метод в классовом компоненте.
При вызове он проверяет this.props и this.state и возвращает один из следующих вариантов: Элемент React, Массивы и фрагменты, Порталы, Строки и числа, Booleans или null

- constructor() - Конструктор компонента React вызывается до того, как компонент будет примонтирован. В начале конструктора необходимо вызывать super(props). Если это не сделать, this.props не будет определён. Это может привести к багам.
  Конструкторы в React обычно используют для двух целей: Инициализация внутреннего состояния через присвоение объекта this.state. Привязка обработчиков событий к экземпляру.
  Конструктор — единственное место, где можно напрямую изменять this.state. В остальных методах необходимо использовать this.setState().

- componentDidMount() - вызывается сразу после монтирования (то есть, вставки компонента в DOM). В этом методе должны происходить действия, которые требуют наличия DOM-узлов. Это хорошее место для создания сетевых запросов.
  Этот метод подходит для настройки подписок. Но не забудьте отписаться от них в componentWillUnmount().

- componentDidUpdate(prevProps, prevState, snapshot) - вызывается сразу после обновления. Не вызывается при первом рендере. Метод позволяет работать с DOM при обновлении компонента. Также он подходит для выполнения таких сетевых запросов, которые выполняются на основании результата сравнения текущих пропсов с предыдущими. Если пропсы не изменились, новый запрос может и не требоваться.

- componentWillUnmount() - вызывается непосредственно перед размонтированием и удалением компонента. В этом методе выполняется необходимый сброс: отмена таймеров, сетевых запросов и подписок, созданных в componentDidMount().

- shouldComponentUpdate(nextProps, nextState) - вызывается перед рендером, когда получает новые пропсы или состояние. Значение по умолчанию равно true. Этот метод нужен только для повышения производительности.. Но не опирайтесь на его возможность «предотвратить» рендер, это может привести к багам. Вместо этого используйте PureComponent, который позволяет не описывать поведение shouldComponentUpdate() вручную. PureComponent поверхностно сравнивает пропсы и состояние и позволяет не пропустить необходимое обновление.

- static getDerivedStateFromProps(props, state) - вызывается непосредственно перед вызовом метода render, как при начальном монтировании, так и при последующих обновлениях. Он должен вернуть объект для обновления состояния или null, чтобы ничего не обновлять.
  Этот метод существует для редких случаев, когда состояние зависит от изменений в пропсах.

- getSnapshotBeforeUpdate(prevProps, prevState) - вызывается прямо перед этапом «фиксирования» (например, перед добавлением в DOM). Он позволяет вашему компоненту брать некоторую информацию из DOM (например, положение прокрутки) перед её возможным изменением. Любое значение, возвращаемое этим методом жизненного цикла, будет передано как параметр componentDidUpdate().

- static getDerivedStateFromError(error) - Этот метод жизненного цикла вызывается после возникновения ошибки у компонента-потомка. Он получает ошибку в качестве параметра и возвращает значение для обновления состояния. getDerivedStateFromError() вызывается во время этапа «рендера». Поэтому здесь запрещены любые побочные эффекты, но их можно использовать в componentDidCatch().

- componentDidCatch(error, info) - Этот метод жизненного цикла вызывается после возникновения ошибки у компонента-потомка. Он получает два параметра: error — перехваченная ошибка, info — объект с ключом componentStack, содержащий информацию о компоненте, в котором произошла ошибка. Метод можно использовать для логирования ошибок.

<img src='https://camo.githubusercontent.com/5de529ff1ae2c01cbb863f8f49123384959b23f317e4a76f7bd58be8b08b7434/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f313630302f312a6350777655685a726e423164745a6e6a4245665866412e706e67'>

</details>

<details>
  <summary>Что такое Virtual DOM (VDOM)</summary>

DOM расшифровывается как Document Object Model (объектная модель документа). Проще говоря, DOM — это представление пользовательского интерфейса (user interface, UI) в приложении. При каждом изменении UI, DOM также обновляется для отображения этих изменений. Частые манипуляции с DOM негативно влияют на производительность.

DOM представляет собой древовидную структуру данных. Поэтому изменения и обновления самого DOM являются достаточно быстрыми. Но после изменения обновленный элемент и все его потомки (дочерние элементы) должны быть повторно отрисованы (отрендерены) для обновления UI приложения. Повторный рендеринг — очень медленный процесс. Таким образом, чем больше у нас компонентов UI, тем более дорогими с точки зрения производительности являются обновления DOM.

Неэффективное обновление часто становится серьезной проблемой. Для решения данной проблемы команда React популяризовала нечто под названием виртуальный (virtual) DOM (VDOM).

В React для каждого объекта настоящего DOM (далее — RDOM) существует соответствующий объект VDOM. VDOM — это объектное представление RDOM, его легковесная копия. VDOM содержит те же свойства, что и RDOM, но не может напрямую влиять на то, что отображается на экране.

  <img src='https://habrastorage.org/r/w780/getpro/habr/post_images/a24/a2a/a11/a24a2aa1136f517abc80ae25c20f6c8a.png'>

  <p><i>Источник: <a href='https://habr.com/ru/company/macloud/blog/558682/'>habr.com</a></i></p>
</details>

<details>
  <summary>useMemo</summary>

Хук React useMemo возвращает запомненное значение.

```javascript
const cachedValue = useMemo(calculateValue, dependencies);
```

`calculateValue`: функция, вычисляющая значение, которое вы хотите кэшировать. Он должен быть чистым, не должен принимать аргументов и должен возвращать значение любого типа. React вызовет вашу функцию во время начального рендеринга. При последующих рендерингах React снова вернет то же значение, если зависимости не изменились с момента последнего рендеринга. В противном случае он вызовет calculateValue, вернет свой результат и сохранит его на случай, если его можно будет повторно использовать позже.

`dependencies`: список всех реактивных значений, на которые есть ссылки внутри кода `calculateValue`. Реактивные значения включают реквизиты, состояние и все переменные и функции, объявленные непосредственно внутри тела вашего компонента. Если ваш линтер настроен для React, он проверит, правильно ли указано каждое реактивное значение в качестве зависимости. Список зависимостей должен иметь постоянное количество элементов и быть встроенным, например `[dep1, dep2, dep3]`. React будет сравнивать каждую зависимость с ее предыдущим значением, используя алгоритм сравнения `Object.is`.

Думайте о запоминании как о кэшировании значения, чтобы его не нужно было пересчитывать.

Хук useMemo запускается только при обновлении одной из его зависимостей.

</details>

<details>
  <summary>useCallback</summary>

Хук React useCallback возвращает мемоизированный callback.

```javascript
const cachedFn = useCallback(fn, dependencies);
```

`fn`: значение функции, которое вы хотите кэшировать. Он может принимать любые аргументы и возвращать любые значения. React вернет (не вызовет!) вашу функцию обратно вам во время первоначального рендеринга. При последующих рендерах React снова предоставит вам ту же функцию, если зависимости не изменились с момента последнего рендеринга. В противном случае он даст вам функцию, которую вы передали во время текущего рендеринга, и сохранит ее на случай, если ее можно будет повторно использовать позже. React не будет вызывать вашу функцию. Функция возвращается вам, чтобы вы могли решить, когда и нужно ли ее вызывать.

`dependencies`: список всех реактивных значений, на которые ссылается код `fn`. Реактивные значения включают реквизиты, состояние и все переменные и функции, объявленные непосредственно внутри тела вашего компонента. Если ваш линтер настроен для React, он проверит, правильно ли указано каждое реактивное значение в качестве зависимости. Список зависимостей должен иметь постоянное количество элементов и быть встроенным, например `[dep1, dep2, dep3]`. React будет сравнивать каждую зависимость с ее предыдущим значением, используя алгоритм сравнения `Object.is`.

Думайте о мемоизации как о кэшировании значения, чтобы его не нужно было пересчитывать.

Это позволяет нам изолировать ресурсоемкие функции, чтобы они не запускались автоматически при каждом рендеринге.

Хук useCallback запускается только при обновлении одной из его зависимостей.

</details>

<details>
  <summary>memo</summary>

Оберните компонент `в memo`, чтобы получить мемоизированную версию этого компонента. Эта запомненная версия вашего компонента обычно не будет повторно отображаться при повторном отображении его родительского компонента, если его `props` не изменились.

```javascript
const MemoizedComponent = memo(SomeComponent, arePropsEqual?)
```

- Component: Component, который вы хотите запомнить. Мемо не изменяет этот компонент, а вместо этого возвращает новый мемоизированный компонент. Допускается любой действительный компонент React, включая функции и компоненты forwardRef.

- optional arePropsEqual: функция, которая принимает два аргумента: `previous props` и `new props`. Он должен возвращать `true`, если старые и новые реквизиты равны: то есть, если компонент будет отображать один и тот же вывод и вести себя с новыми реквизитами так же, как и со старыми. В противном случае он должен вернуть `false`.

memo возвращает новый компонент React. Он ведет себя так же, как компонент, предоставленный для memo, за исключением того, что React не всегда будет повторно отображать его при повторном отображении его родителя, если его `props` не изменились.

</details>

## Authorization

<details>
  <summary>Authorization vs Authentication</summary>

Для начала система запрашивает логин, пользователь его указывает, система распознает его как существующий — это <ins>**идентификация**</ins>.

После этого Google просит ввести пароль, пользователь его вводит, и система соглашается, что пользователь, похоже, действительно настоящий, раз пароль совпал, — это <ins>**аутентификация**</ins>.

Скорее всего, Google дополнительно спросит еще и одноразовый код из SMS или приложения. Если пользователь и его правильно введет, то система окончательно согласится с тем, что он настоящий владелец аккаунта, — это <ins>**двухфакторная аутентификация**</ins>.

После этого система предоставит пользователю право читать письма в его почтовом ящике и все в таком духе — <ins>**это авторизация**</ins>.

Популярные методы аутентификации:

- Аутентификация на основе пароля - это простой метод аутентификации, для которого требуется пароль для подтверждения личности пользователя.
- Аутентификация без пароля - это когда пользователь проверяется с помощью OTP или волшебной ссылки, доставленной на зарегистрированный адрес электронной почты или номер телефона.
- 2FA / MFA требует более одного уровня безопасности, например дополнительного PIN-кода или секретного вопроса, для идентификации пользователя и предоставления доступа к системе.
- Социальная аутентификация проверяет и аутентифицирует пользователей с существующими учетными данными из социальных сетей.

Популярные методы авторизации:

- Контроль доступа на основе ролей (RBAC) может быть реализован для управления привилегиями между системой и пользователем.
- Веб-токен JSON (JWT) - это открытый стандарт для безопасной передачи данных между сторонами, и пользователи авторизуются с помощью пары открытого / закрытого ключей.

Источник: [kaspersky.ru](https://www.kaspersky.ru/blog/identification-authentication-authorization-difference/29123/)

</details>

<details>
<summary>JWT token</summary>

Структура JWT

WT состоит из трех частей: заголовок header, полезные данные payload и подпись signature. Давайте пройдемся по каждой из них.

**Шаг 1. Создаем HEADER**

Хедер JWT содержит информацию о том, как должна вычисляться JWT подпись. Хедер — это тоже JSON объект, который выглядит следующим образом:

```javascript
header = { alg: "HS256", typ: "JWT" };
```

Поле typ не говорит нам ничего нового, только то, что это JSON Web Token. Интереснее здесь будет поле alg, которое определяет алгоритм хеширования. Он будет использоваться при создании подписи. HS256 — не что иное, как HMAC-SHA256, для его вычисления нужен лишь один секретный ключ (более подробно об этом в шаге 3). Еще может использоваться другой алгоритм RS256 — в отличие от предыдущего, он является ассиметричным и создает два ключа: публичный и приватный. С помощью приватного ключа создается подпись, а с помощью публичного только лишь проверяется подлинность подписи, поэтому нам не нужно беспокоиться о его безопасности.

**Шаг 2. Создаем PAYLOAD**

Payload — это полезные данные, которые хранятся внутри JWT. Эти данные также называют JWT-claims (заявки). В примере, который рассматриваем мы, сервер аутентификации создает JWT с информацией об id пользователя — userId.

```javascript
payload = { userId: "b08f86af-35da-48f2-8fab-cef3904660bd" };
```

Мы положили только одну заявку (claim) в payload. Вы можете положить столько заявок, сколько захотите. Существует список стандартных заявок для JWT payload — вот некоторые из них:

- iss (issuer) — определяет приложение, из которого отправляется токен.
- sub (subject) — определяет тему токена.
- exp (expiration time) — время жизни токена.

Эти поля могут быть полезными при создании JWT, но они не являются обязательными. Если хотите знать весь список доступных полей для JWT, можете заглянуть в Wiki. Но стоит помнить, что чем больше передается информации, тем больший получится в итоге сам JWT. Обычно с этим не бывает проблем, но все-таки это может негативно сказаться на производительности и вызвать задержки во взаимодействии с сервером.

**Шаг 3. Создаем SIGNATURE**

Сначала header и payload приводятся к формату JSON, а затем переводятся в base64. Подпись вычисляется с использование следующего псевдо-кода:

```javascript
const SECRET_KEY = "cAtwa1kkEy";
const unsignedToken = base64urlEncode(header) + "." + base64urlEncode(payload);
const signature = HMAC - SHA256(unsignedToken, SECRET_KEY);
```

Алгоритм base64url кодирует хедер и payload, созданные на 1 и 2 шаге. Алгоритм соединяет закодированные строки через точку. Затем полученная строка хешируется алгоритмом, заданным в хедере на основе нашего секретного ключа.

```javascript
// header eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9
// payload eyJ1c2VySWQiOiJiMDhmODZhZi0zNWRhLTQ4ZjItOGZhYi1jZWYzOTA0NjYwYmQifQ
// signature -xN_h82PHVTCMA9vdoHrcZxH-x5mb11y1537t3rGzcM
```

**Шаг 4. Теперь объединим все три JWT компонента вместе**

Теперь, когда у нас есть все три составляющих, мы можем создать наш JWT. Это довольно просто, мы соединяем все полученные элементы в строку через точку.

```javascript
const token =
  encodeBase64Url(header) +
  "." +
  encodeBase64Url(payload) +
  "." +
  encodeBase64Url(signature);
// JWT Token
// eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VySWQiOiJiMDhmODZhZi0zNWRhLTQ4ZjItOGZhYi1jZWYzOTA0NjYwYmQifQ.-xN_h82PHVTCMA9vdoHrcZxH-x5mb11y1537t3rGzcM
```

Источник: [habr.com/](https://habr.com/ru/post/340146/)

</details>

## Анализ данных

<details>
  <summary>Что такое анализ данных? Какие этапы включает?</summary>

- **Сбор данных**: получение данных с устройств (например, с холтера), из файлов, API и т.д.
- **Очистка данных**: удаление шумов, пропусков, некорректных значений.
- **Обработка данных**: фильтрация, нормализация, преобразование формата.
- **Анализ**: извлечение признаков, поиск аномалий, статистика.
- **Визуализация**: графики, таблицы, отчеты.
- **Интерпретация**: выводы на основе анализа.

</details>

<details>
  <summary>Что включает в себя очистка данных?</summary>

### 1. Что такое очистка данных?

Очистка данных — это процесс удаления или исправления некорректных, шумных, пропущенных или неуместных данных.

В контексте ЭКГ это может быть:

- Удаление шумов (электрические помехи, дрейф базовой линии)
- Удаление или исправление пропусков (NaN, null, пустые значения)
- Удаление выбросов (аномально высокие/низкие значения)
- Исправление формата данных (например, преобразование строк в числа)

### 2. Типовые проблемы с данными ЭКГ

- Шум: высокочастотные помехи, дрейф базовой линии, артефакты движения.
- Пропуски: отсутствующие значения из-за сбоев в записи.
- Выбросы: внезапные скачки, нехарактерные для физиологического сигнала.
- Дублирование: повторяющиеся значения или записи.

### 3. Методы очистки данных

#### 3.1. Удаление или замена пропусков

Удаление:

```javascript
const cleaned = data.filter((x) => x !== null && !isNaN(x));
```

Замена на среднее/интерполяция:

```javascript
function fillMissing(data) {
  return data.map((x, i, arr) => {
    if (x !== null && !isNaN(x)) return x;
    // Пример: взять среднее соседей
    const prev = arr[i - 1] ?? 0;
    const next = arr[i + 1] ?? 0;
    return (prev + next) / 2;
  });
}
```

#### 3.2. Удаление выбросов

Простой порог:

```javascript
const threshold = 5; // пример порога, зависит от амплитуды ЭКГ
const filtered = data.filter((x) => Math.abs(x) < threshold);
```

Более умный способ — по стандартному отклонению:

```javascript
function removeOutliers(data) {
  const mean = data.reduce((a, b) => a + b, 0) / data.length;
  const std = Math.sqrt(
    data.map((x) => (x - mean) ** 2).reduce((a, b) => a + b, 0) / data.length
  );
  return data.filter((x) => Math.abs(x - mean) < 3 * std);
}
```

#### 3.2. Удаление выбросов

Простой порог:

```javascript
const filtered = data.filter((x) => Math.abs(x) < threshold);
```

Более умный способ — по стандартному отклонению:

```javascript
function removeOutliers(data) {
  const mean = data.reduce((a, b) => a + b, 0) / data.length;
  const std = Math.sqrt(
    data.map((x) => (x - mean) ** 2).reduce((a, b) => a + b, 0) / data.length
  );
  return data.filter((x) => Math.abs(x - mean) < 3 * std);
}
```

#### 3.3. Фильтрация шума

Скользящее среднее:

```javascript
function movingAverage(data, windowSize) {
  const result = [];
  for (let i = 0; i < data.length; i++) {
    let sum = 0;
    let count = 0;
    for (
      let j = i - Math.floor(windowSize / 2);
      j <= i + Math.floor(windowSize / 2);
      j++
    ) {
      if (j >= 0 && j < data.length) {
        sum += data[j];
        count++;
      }
    }
    result.push(sum / count);
  }
  return result;
}
```

Медианный фильтр:

```javascript
function medianFilter(data, windowSize) {
  const result = [];
  for (let i = 0; i < data.length; i++) {
    const window = [];
    for (
      let j = i - Math.floor(windowSize / 2);
      j <= i + Math.floor(windowSize / 2);
      j++
    ) {
      if (j >= 0 && j < data.length) window.push(data[j]);
    }
    window.sort((a, b) => a - b);
    result.push(window[Math.floor(window.length / 2)]);
  }
  return result;
}
```

#### 3.4. Удаление дубликатов

Если данные — массив объектов с метками времени:

```javascript
const unique = [];
const seen = new Set();
for (const item of data) {
  if (!seen.has(item.timestamp)) {
    unique.push(item);
    seen.add(item.timestamp);
  }
}
```

### 4. Практический pipeline очистки данных

1. Удалить пропуски (или заполнить их)
2. Удалить выбросы (по порогу или стандартному отклонению)
3. Применить фильтр (скользящее среднее или медианный)
4. Удалить дубликаты (если есть)

### 5. Возможные вопросы на собеседовании

- Как бы ты обработал NaN/undefined значения в массиве данных?
- Как бы ты нашёл и удалил выбросы?
- Как бы ты убрал шум из ЭКГ-сигнала?
- Как бы ты обработал данные, если они приходят с устройства в реальном времени?

### 6. Пример: полный pipeline очистки

```javascript
function cleanECG(rawData) {
  // 1. Удаляем пропуски
  let data = rawData.filter((x) => x !== null && !isNaN(x));
  // 2. Удаляем выбросы
  const mean = data.reduce((a, b) => a + b, 0) / data.length;
  const std = Math.sqrt(
    data.map((x) => (x - mean) ** 2).reduce((a, b) => a + b, 0) / data.length
  );
  data = data.filter((x) => Math.abs(x - mean) < 3 * std);
  // 3. Фильтруем шум
  data = movingAverage(data, 5);
  // 4. (опционально) Удаляем дубликаты, если есть метки времени
  return data;
}
```

</details>

<details>
  <summary>Очистка данных с помощью потоков</summary>

#### 1. Зачем использовать потоки?

- Позволяют обрабатывать большие файлы по частям, не загружая всё в память.
- Можно сразу фильтровать, очищать и преобразовывать данные "на лету".
- Удобно для реального времени или при работе с устройствами.

#### 2. Типовой pipeline с потоками

1. Чтение файла потоком (fs.createReadStream)
2. Парсинг данных (например, CSV — через csv-parser)
3. Очистка данных (фильтрация, удаление выбросов, NaN и т.д.)
4. Запись очищенных данных (например, в новый файл через fs.createWriteStream)

#### 3. Пример: очистка CSV-файла с ЭКГ

```javascript
const fs = require("fs");
const csv = require("csv-parser");
const { Transform } = require("stream");

// 1. Создаём поток для чтения исходного файла
const readStream = fs.createReadStream("ecg_raw.csv");

// 2. Создаём поток для записи очищенных данных
const writeStream = fs.createWriteStream("ecg_cleaned.csv");

// 3. Трансформирующий поток для очистки данных
const cleanStream = new Transform({
  objectMode: true,
  transform(row, encoding, callback) {
    // row — объект, например: { time: '...', value: '...' }
    const value = Number(row.value);

    // Удаляем пропуски и выбросы
    if (!isNaN(value) && Math.abs(value) < 5) {
      // 5 — пример порога
      // Можно добавить сглаживание, если нужно
      // Например, скользящее среднее (реализовать буфер)
      this.push(`${row.time},${value}\n`);
    }
    callback();
  },
});

// 4. Запускаем pipeline
readStream
  .pipe(csv()) // парсим CSV в объекты
  .pipe(cleanStream) // очищаем данные
  .pipe(writeStream) // пишем в новый файл
  .on("finish", () => {
    console.log("Очистка завершена!");
  });
```

Очистка бинарных данных

```javascript
const fs = require("fs");
const { Transform } = require("stream");

// Размер одного значения (2 байта для 16-битного числа)
const VALUE_SIZE = 2;
const THRESHOLD = 5000; // пример порога для выбросов

const readStream = fs.createReadStream("ecg_raw.bin");
const writeStream = fs.createWriteStream("ecg_cleaned.bin");

const cleanStream = new Transform({
  transform(chunk, encoding, callback) {
    // chunk — Buffer
    let cleanedBuffer = Buffer.alloc(0);

    for (let i = 0; i < chunk.length; i += VALUE_SIZE) {
      // Читаем 16-битное signed значение (Little Endian)
      if (i + 1 >= chunk.length) break; // если не хватает байтов
      const value = chunk.readInt16LE(i);

      // Фильтрация: убираем выбросы и NaN
      if (!isNaN(value) && Math.abs(value) < THRESHOLD) {
        // Добавляем в новый буфер
        const buf = Buffer.alloc(VALUE_SIZE);
        buf.writeInt16LE(value, 0);
        cleanedBuffer = Buffer.concat([cleanedBuffer, buf]);
      }
    }

    this.push(cleanedBuffer);
    callback();
  },
});

readStream
  .pipe(cleanStream)
  .pipe(writeStream)
  .on("finish", () => {
    console.log("Очистка бинарного файла завершена!");
  });
```

#### 4. Как добавить скользящее среднее в поток?

Можно реализовать буфер внутри `Transform`-потока:

```javascript
const windowSize = 5;
let buffer = [];

const cleanStream = new Transform({
  objectMode: true,
  transform(row, encoding, callback) {
    const value = Number(row.value);
    if (!isNaN(value) && Math.abs(value) < 5) {
      buffer.push(value);
      if (buffer.length > windowSize) buffer.shift();
      // Считаем среднее по буферу
      const avg = buffer.reduce((a, b) => a + b, 0) / buffer.length;
      this.push(`${row.time},${avg}\n`);
    }
    callback();
  },
});
```

#### 5. Преимущества такого подхода

- Не нужно держать весь файл в памяти.
- Можно обрабатывать данные "на лету" (например, с устройства).
- Легко масштабируется для больших данных.

#### 6. Возможные вопросы на собеседовании

- Как бы ты реализовал очистку данных в потоке?
- Как обрабатывать данные, если они приходят с устройства в реальном времени?
- Как добавить фильтрацию или сглаживание в поток?

</details>

<details>
  <summary>Из чего состоит обработка сигналов?</summary>

### 1. Что такое обработка сигналов?

Обработка сигналов — это преобразование, анализ и интерпретация цифровых или аналоговых сигналов для извлечения полезной информации, удаления шума, выделения признаков и подготовки к анализу.  
В медицине (например, ЭКГ) — это работа с временными рядами, где каждый элемент массива — это измерение напряжения в определённый момент времени.

**Что такое ЭКГ-сигнал? Какие у него основные характеристики?**

- Электрокардиограмма (`ЭКГ`) — это запись электрической активности сердца.
- Основные элементы: `PQRST-комплекс` (`P` — деполяризация предсердий, `QRS` — деполяризация желудочков, `T` — реполяризация желудочков).
- Важные параметры: **`ЧСС`** (`частота сердечных сокращений`), интервалы между пиками, амплитуда.

**Как бы ты нашел аномалии в данных ЭКГ?**

- Сначала фильтруешь шум (например, с помощью фильтра скользящего среднего).
- Находишь `R-пики`**(самые высокие пики в `QRS`-комплексе)**.
- Анализируешь интервалы между ними — если они слишком короткие/длинные, это может быть аритмия.
- Сравниваешь с нормальными значениями.

**Как посчитать ЧСС (частоту сердечных сокращений) по ЭКГ?**

- Находишь все `R-пики`.
- Считаешь интервалы между ними (в миллисекундах).
- ЧСС = 60 000 / средний интервал (если интервалы в мс).

### 2. Основные этапы обработки сигналов

#### 2.1. Фильтрация шума

- Зачем: Удалить помехи (например, дрейф базовой линии, электромагнитные шумы, артефакты движения).
- Примеры фильтров:
  - Скользящее среднее (Moving Average): Сглаживает сигнал, убирает мелкие шумы.
  - Медианный фильтр: Убирает одиночные выбросы.
  - Цифровые фильтры (Butterworth, Чебышёва): Для более сложной фильтрации (реже в JS, чаще в Python/Matlab).

#### 2.2. Детекция событий (например, R-пиков)

- Зачем: Найти ключевые точки сигнала (например, R-пики в ЭКГ для расчёта ЧСС).
- Методы:
  - Поиск локальных максимумов выше определённого порога.
  - Использование производной сигнала для поиска резких изменений.

#### 2.3. Извлечение признаков (feature extraction)

- Зачем: Получить числовые характеристики для анализа (например, ЧСС, интервалы RR, амплитуды).
- Примеры:

  - Среднее, стандартное отклонение, максимумы/минимумы.
  - Интервалы между R-пиками (RR-интервалы).

#### 2.4. Сегментация сигнала

- Зачем: Разделить длинный сигнал на участки (например, по минутам или по событиям).
- Пример: Разбить массив на куски по 10 секунд для анализа каждого отдельно.

</details>

<details>
  <summary>Разница между обработкой сигналов и очисткой данных</summary>

#### Очистка данных (Data Cleaning)

**Цель:**
Сделать данные пригодными для анализа, убрать явные ошибки и мусор.
Что включает:

- Удаление или замена пропусков (NaN, null, пустые значения)
- Удаление выбросов (аномально большие/маленькие значения)
- Исправление формата (например, преобразование строк в числа)
- Удаление дубликатов

**Пример:**  
В массиве ЭКГ есть значения null, NaN, или внезапно встречается 99999 — ты их убираешь или заменяешь.

##

#### Обработка сигналов (Signal Processing)

**Цель:**
Извлечь полезную информацию из временного ряда, подготовить сигнал к анализу, выделить особенности.
Что включает:

- Фильтрация шума (скользящее среднее, медианный фильтр, цифровые фильтры)
- Детекция событий (например, поиск R-пиков)
- Извлечение признаков (расчёт ЧСС, амплитуд, интервалов)
- Сегментация сигнала (разделение на участки)
- Преобразования (например, Фурье-преобразование)

**Пример:**  
Сигнал ЭКГ "прыгает" из-за помех — ты сглаживаешь его фильтром, находишь R-пики, считаешь интервалы между ними.

##

**Визуальная аналогия**

- Очистка данных — как помыть и почистить картошку.
- Обработка сигналов — как нарезать, сварить и приготовить из неё блюдо.
</details>

<details>
  <summary>Из чего состоит анализ данных?</summary>

### 1. Что такое анализ данных?

Анализ данных — это этап, на котором из подготовленных (очищенных и обработанных) данных извлекается полезная информация, делаются выводы.

### 2. Что включает анализ данных (на примере ЭКГ)?

#### 2.1. Извлечение признаков (Feature Extraction)

- Примеры признаков:

  - Частота сердечных сокращений (ЧСС, HR)
  - Интервалы между R-пиками (RR-интервалы)
  - Амплитуда пиков
  - Вариабельность ритма (HRV)
  - Количество экстрасистол, пауз, аритмий

#### 2.2. Статистический анализ

- Среднее, медиана, стандартное отклонение — для оценки стабильности ритма.
- Гистограммы, распределения — для поиска аномалий.

#### 2.3. Поиск аномалий

- Аритмии: слишком короткие или длинные RR-интервалы.
- Экстрасистолы: внеочередные сокращения.
- Паузы: отсутствие пиков дольше определённого времени.

</details>
<br>

## ЭКГ

<details>
  <summary>Расшифровка ЭКГ</summary>
  
![ЭКГ](./assets/eсg.png)
![ЭКГ](./assets/eсg-2.png)

ЗНАЧЕНИЕ P: Данное значение является суммарным возбуждением обоих предсердий, другими словами пик P — это синусовое возбуждение по проводящим путям от правого предсердиям к левому.

ИНТЕРВАЛ P — Q: Этот интервал говорит о естественной задержке импульса, который проходит по нижней веточке пучка Бахмана и попадает в предсердно-желудочковое соединение.

ИНТЕРВАЛ Q, R, S: Далее импульс проходит по проводящим путям достигает желудочков. Этот процесс на графике изображен в виде интервала QRS.

ИНТЕРВАЛ S — T: Этот интервал отображает процесс угасания возбуждения клеток миокарда. На графике данный процесс отображен на интервале от S до зубца T.

</details>
<br>

